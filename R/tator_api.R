# coding: utf-8

# Tator REST API
#
# Interface to the Tator backend.
#
# The version of the OpenAPI document: v1
# 
# Generated by: https://openapi-generator.tech


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from tator.api_client import ApiClient
from tator.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class TatorApi(object):
    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def AlgorithmLaunch(self, project, **kwargs):
        """AlgorithmLaunch

        Launch a registered algorithm.  This will create one or more Argo workflows that execute the named algorithm registration. To get a list of available algorithms, use the `Algorithms` endpoint. A media list will be submitted for processing using either a query string or  a list of media IDs. If neither are included, the algorithm will be launched on all media in the project.   Media is divided into batches for based on the `files_per_job` field of the  `Algorithm` object. One batch is submitted to each Argo workflow.  Submitted algorithm jobs may be cancelled via the `Job` or `JobGroup` endpoints. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.AlgorithmLaunch(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param AlgorithmLaunchSpec algorithm.launch.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.AlgorithmLaunch`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.AlgorithmLaunch_with_http_info(project, **kwargs)  # noqa: E501

    def AlgorithmLaunch_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Launch a registered algorithm.  This will create one or more Argo workflows that execute the named algorithm registration. To get a list of available algorithms, use the `Algorithms` endpoint. A media list will be submitted for processing using either a query string or  a list of media IDs. If neither are included, the algorithm will be launched on all media in the project.   Media is divided into batches for based on the `files_per_job` field of the  `Algorithm` object. One batch is submitted to each Argo workflow.  Submitted algorithm jobs may be cancelled via the `Job` or `JobGroup` endpoints.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.AlgorithmLaunch_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param AlgorithmLaunchSpec algorithm.launch.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.AlgorithmLaunch`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'algorithm.launch.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method AlgorithmLaunch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `AlgorithmLaunch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'algorithm.launch.spec' in local_var_params:
            body_params = local_var_params['algorithm.launch.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/AlgorithmLaunch/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlgorithmLaunch',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateAnalysis(self, project, **kwargs):
        """CreateAnalysis

        Create analysis.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateAnalysis(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param AnalysisSpec analysis.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateAnalysis_with_http_info(project, **kwargs)  # noqa: E501

    def CreateAnalysis_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Create analysis.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateAnalysis_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param AnalysisSpec analysis.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'analysis.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateAnalysis" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `CreateAnalysis`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'analysis.spec' in local_var_params:
            body_params = local_var_params['analysis.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Analyses/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateLeafList(self, project, **kwargs):
        """CreateLeafList

        Create leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method does a bulk create on a list of `LeafSpec` objects. A  maximum of 500 leaves may be created in one request. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateLeafList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[LeafSpec] leaf.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateListResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateLeafList_with_http_info(project, **kwargs)  # noqa: E501

    def CreateLeafList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Create leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method does a bulk create on a list of `LeafSpec` objects. A  maximum of 500 leaves may be created in one request.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateLeafList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[LeafSpec] leaf.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateListResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'leaf.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateLeafList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `CreateLeafList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'leaf.spec' in local_var_params:
            body_params = local_var_params['leaf.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Leaves/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateLeafType(self, project, **kwargs):
        """CreateLeafType

        Create leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateLeafType(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param LeafTypeSpec leaf.type.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateLeafType_with_http_info(project, **kwargs)  # noqa: E501

    def CreateLeafType_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Create leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateLeafType_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param LeafTypeSpec leaf.type.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'leaf.type.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateLeafType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `CreateLeafType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'leaf.type.spec' in local_var_params:
            body_params = local_var_params['leaf.type.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LeafTypes/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateLocalizationList(self, project, **kwargs):
        """CreateLocalizationList

        Create localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk create on a list of `LocalizationSpec` objects. A  maximum of 500 localizations may be created in one request. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateLocalizationList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[LocalizationSpec] localization.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateListResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateLocalizationList_with_http_info(project, **kwargs)  # noqa: E501

    def CreateLocalizationList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Create localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk create on a list of `LocalizationSpec` objects. A  maximum of 500 localizations may be created in one request.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateLocalizationList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[LocalizationSpec] localization.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateListResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'localization.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateLocalizationList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `CreateLocalizationList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'localization.spec' in local_var_params:
            body_params = local_var_params['localization.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localizations/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateLocalizationType(self, project, **kwargs):
        """CreateLocalizationType

        Create localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateLocalizationType(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param LocalizationTypeSpec localization.type.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateLocalizationType_with_http_info(project, **kwargs)  # noqa: E501

    def CreateLocalizationType_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Create localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateLocalizationType_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param LocalizationTypeSpec localization.type.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'localization.type.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateLocalizationType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `CreateLocalizationType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'localization.type.spec' in local_var_params:
            body_params = local_var_params['localization.type.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationTypes/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateMediaType(self, project, **kwargs):
        """CreateMediaType

        Create media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateMediaType(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param MediaTypeSpec media.type.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateMediaType_with_http_info(project, **kwargs)  # noqa: E501

    def CreateMediaType_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Create media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateMediaType_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param MediaTypeSpec media.type.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.type.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateMediaType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `CreateMediaType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'media.type.spec' in local_var_params:
            body_params = local_var_params['media.type.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaTypes/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateMembership(self, project, **kwargs):
        """CreateMembership

        Create membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateMembership(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param MembershipSpec membership.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateMembership_with_http_info(project, **kwargs)  # noqa: E501

    def CreateMembership_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Create membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateMembership_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param MembershipSpec membership.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'membership.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateMembership" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `CreateMembership`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'membership.spec' in local_var_params:
            body_params = local_var_params['membership.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Memberships/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateObtainAuthToken(self, **kwargs):
        """CreateObtainAuthToken


        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateObtainAuthToken(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Credentials credentials:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.Token`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateObtainAuthToken_with_http_info(**kwargs)  # noqa: E501

    def CreateObtainAuthToken_with_http_info(self, **kwargs):  # noqa: E501
        """

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateObtainAuthToken_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Credentials credentials:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.Token`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'credentials'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateObtainAuthToken" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'credentials' in local_var_params:
            body_params = local_var_params['credentials']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Token',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateProgressSummaryAPI(self, project, **kwargs):
        """CreateProgressSummaryAPI

        Create or update a progress summary.  This endpoint sets a key in redis that indicates how many jobs are in a job group as well as how many are completed. This is used to display summary progress in the progress bar. If not used for a given job group, the job completion is computed from the status of individual jobs in the group. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateProgressSummaryAPI(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param ProgressSummarySpec progress.summary.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateProgressSummaryAPI_with_http_info(project, **kwargs)  # noqa: E501

    def CreateProgressSummaryAPI_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Create or update a progress summary.  This endpoint sets a key in redis that indicates how many jobs are in a job group as well as how many are completed. This is used to display summary progress in the progress bar. If not used for a given job group, the job completion is computed from the status of individual jobs in the group.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateProgressSummaryAPI_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param ProgressSummarySpec progress.summary.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'progress.summary.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateProgressSummaryAPI" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `CreateProgressSummaryAPI`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'progress.summary.spec' in local_var_params:
            body_params = local_var_params['progress.summary.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/ProgressSummary/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateProject(self, **kwargs):
        """CreateProject

        Create project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateProject(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ProjectSpec project.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateProject_with_http_info(**kwargs)  # noqa: E501

    def CreateProject_with_http_info(self, **kwargs):  # noqa: E501
        """
        Create project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateProject_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ProjectSpec project.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateProject" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project.spec' in local_var_params:
            body_params = local_var_params['project.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateStateList(self, project, **kwargs):
        """CreateStateList

        Create state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk create on a list of `StateSpec` objects. A  maximum of 500 states may be created in one request. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateStateList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[StateSpec] state.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateListResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateStateList_with_http_info(project, **kwargs)  # noqa: E501

    def CreateStateList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Create state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk create on a list of `StateSpec` objects. A  maximum of 500 states may be created in one request.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateStateList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[StateSpec] state.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateListResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'state.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateStateList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `CreateStateList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'state.spec' in local_var_params:
            body_params = local_var_params['state.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/States/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateStateType(self, project, **kwargs):
        """CreateStateType

        Create state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateStateType(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param StateTypeSpec state.type.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateStateType_with_http_info(project, **kwargs)  # noqa: E501

    def CreateStateType_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Create state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateStateType_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param StateTypeSpec state.type.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'state.type.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateStateType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `CreateStateType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'state.type.spec' in local_var_params:
            body_params = local_var_params['state.type.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/StateTypes/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateTemporaryFile(self, project, **kwargs):
        """CreateTemporaryFile

        Create temporary file.  Temporary files are files stored server side for a defined duration.   The file must first be uploaded via tus, and can subsequently be saved using this endpoint.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateTemporaryFile(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param TemporaryFileSpec temporary.file.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateTemporaryFile_with_http_info(project, **kwargs)  # noqa: E501

    def CreateTemporaryFile_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Create temporary file.  Temporary files are files stored server side for a defined duration.   The file must first be uploaded via tus, and can subsequently be saved using this endpoint.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateTemporaryFile_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param TemporaryFileSpec temporary.file.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'temporary.file.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateTemporaryFile" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `CreateTemporaryFile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'temporary.file.spec' in local_var_params:
            body_params = local_var_params['temporary.file.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TemporaryFiles/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def CreateVersion(self, project, **kwargs):
        """CreateVersion

        Create version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateVersion(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param VersionSpec version.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.CreateVersion_with_http_info(project, **kwargs)  # noqa: E501

    def CreateVersion_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Create version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.CreateVersion_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param VersionSpec version.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'version.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method CreateVersion" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `CreateVersion`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'version.spec' in local_var_params:
            body_params = local_var_params['version.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Versions/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteJob(self, run.uid, **kwargs):
        """DeleteJob

        Cancel a background job.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.  This endpoint allows the user to cancel a job using the `run_uid` returned by either the `AlgorithmLaunch` or `Transcode` endpoints. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteJob(run.uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param character run.uid: A uuid1 string identifying to single Job. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteJob_with_http_info(run.uid, **kwargs)  # noqa: E501

    def DeleteJob_with_http_info(self, run.uid, **kwargs):  # noqa: E501
        """
        Cancel a background job.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.  This endpoint allows the user to cancel a job using the `run_uid` returned by either the `AlgorithmLaunch` or `Transcode` endpoints.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteJob_with_http_info(run.uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param character run.uid: A uuid1 string identifying to single Job. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'run.uid'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteJob" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'run.uid' is set
        if self.api_client.client_side_validation and ('run.uid' not in local_var_params or  # noqa: E501
                                                        local_var_params['run.uid'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `run.uid` when calling `DeleteJob`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run.uid' in local_var_params:
            path_params['run_uid'] = local_var_params['run.uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Job/{run_uid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteJobGroup(self, group.id, **kwargs):
        """DeleteJobGroup

        Cancel a group of background jobs.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.  This endpoint allows the user to cancel a group of jobs using the `group_id`  returned by either the `AlgorithmLaunch` or `Transcode` endpoints. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteJobGroup(group.id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param character group.id: A uuid1 string identifying a group of jobs. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteJobGroup_with_http_info(group.id, **kwargs)  # noqa: E501

    def DeleteJobGroup_with_http_info(self, group.id, **kwargs):  # noqa: E501
        """
        Cancel a group of background jobs.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.  This endpoint allows the user to cancel a group of jobs using the `group_id`  returned by either the `AlgorithmLaunch` or `Transcode` endpoints.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteJobGroup_with_http_info(group.id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param character group.id: A uuid1 string identifying a group of jobs. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'group.id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteJobGroup" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'group.id' is set
        if self.api_client.client_side_validation and ('group.id' not in local_var_params or  # noqa: E501
                                                        local_var_params['group.id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `group.id` when calling `DeleteJobGroup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group.id' in local_var_params:
            path_params['group_id'] = local_var_params['group.id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/JobGroup/{group_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteLeaf(self, id, **kwargs):
        """DeleteLeaf

        Delete leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteLeaf(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a leaf. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteLeaf_with_http_info(id, **kwargs)  # noqa: E501

    def DeleteLeaf_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Delete leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteLeaf_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a leaf. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteLeaf" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `DeleteLeaf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Leaf/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteLeafList(self, project, **kwargs):
        """DeleteLeafList

        Delete leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method performs a bulk delete on all leaves matching a query. It is  recommended to use a GET request first to check what is being deleted. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteLeafList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character ancestor: Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia).
        :param integer type: Unique integer identifying a leaf type.
        :param character name: Name of the leaf element.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteLeafList_with_http_info(project, **kwargs)  # noqa: E501

    def DeleteLeafList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Delete leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method performs a bulk delete on all leaves matching a query. It is  recommended to use a GET request first to check what is being deleted.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteLeafList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character ancestor: Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia).
        :param integer type: Unique integer identifying a leaf type.
        :param character name: Name of the leaf element.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'ancestor',
            'type',
            'name',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteLeafList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `DeleteLeafList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'ancestor' in local_var_params and local_var_params['ancestor'] is not None:  # noqa: E501
            query_params.append(('ancestor', local_var_params['ancestor']))  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Leaves/{project}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteLeafType(self, id, **kwargs):
        """DeleteLeafType

        Delete leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteLeafType(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an leaf type. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteLeafType_with_http_info(id, **kwargs)  # noqa: E501

    def DeleteLeafType_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Delete leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteLeafType_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an leaf type. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteLeafType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `DeleteLeafType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LeafType/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteLocalization(self, id, **kwargs):
        """DeleteLocalization

        Delete localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteLocalization(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a localization. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteLocalization_with_http_info(id, **kwargs)  # noqa: E501

    def DeleteLocalization_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Delete localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteLocalization_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a localization. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteLocalization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `DeleteLocalization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localization/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteLocalizationList(self, project, **kwargs):
        """DeleteLocalizationList

        Delete localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all localizations matching a query. It is  recommended to use a GET request first to check what is being deleted. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteLocalizationList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character media.query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param array[integer] media.id: Comma-separated list of media IDs.
        :param integer type: Unique integer identifying a annotation type.
        :param array[integer] version: List of integers representing versions to fetch
        :param integer modified: Whether to return original or modified annotations, 0 or 1.
        :param integer after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param integer exclude.parents: If a clone is present, do not send parent. (0 or 1)
        :param integer frame: Frame number of this localization if it is in a video.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteLocalizationList_with_http_info(project, **kwargs)  # noqa: E501

    def DeleteLocalizationList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Delete localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all localizations matching a query. It is  recommended to use a GET request first to check what is being deleted.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteLocalizationList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character media.query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param array[integer] media.id: Comma-separated list of media IDs.
        :param integer type: Unique integer identifying a annotation type.
        :param array[integer] version: List of integers representing versions to fetch
        :param integer modified: Whether to return original or modified annotations, 0 or 1.
        :param integer after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param integer exclude.parents: If a clone is present, do not send parent. (0 or 1)
        :param integer frame: Frame number of this localization if it is in a video.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.query',
            'media.id',
            'type',
            'version',
            'modified',
            'after',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop',
            'exclude.parents',
            'frame'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteLocalizationList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `DeleteLocalizationList`")  # noqa: E501

        if self.api_client.client_side_validation and 'exclude.parents' in local_var_params and local_var_params['exclude.parents'] > 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `exclude.parents` when calling `DeleteLocalizationList`, must be a value less than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'exclude.parents' in local_var_params and local_var_params['exclude.parents'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `exclude.parents` when calling `DeleteLocalizationList`, must be a value greater than or equal to `0`")  # noqa: E501
        if self.api_client.client_side_validation and 'frame' in local_var_params and local_var_params['frame'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `frame` when calling `DeleteLocalizationList`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.query' in local_var_params and local_var_params['media.query'] is not None:  # noqa: E501
            query_params.append(('media_query', local_var_params['media.query']))  # noqa: E501
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'version' in local_var_params and local_var_params['version'] is not None:  # noqa: E501
            query_params.append(('version', local_var_params['version']))  # noqa: E501
            collection_formats['version'] = 'csv'  # noqa: E501
        if 'modified' in local_var_params and local_var_params['modified'] is not None:  # noqa: E501
            query_params.append(('modified', local_var_params['modified']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501
        if 'exclude.parents' in local_var_params and local_var_params['exclude.parents'] is not None:  # noqa: E501
            query_params.append(('excludeParents', local_var_params['exclude.parents']))  # noqa: E501
        if 'frame' in local_var_params and local_var_params['frame'] is not None:  # noqa: E501
            query_params.append(('frame', local_var_params['frame']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localizations/{project}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteLocalizationType(self, id, **kwargs):
        """DeleteLocalizationType

        Delete localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   Note that this will also delete any localizations associated with the localization type. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteLocalizationType(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an localization type. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteLocalizationType_with_http_info(id, **kwargs)  # noqa: E501

    def DeleteLocalizationType_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Delete localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   Note that this will also delete any localizations associated with the localization type.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteLocalizationType_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an localization type. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteLocalizationType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `DeleteLocalizationType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationType/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteMedia(self, id, **kwargs):
        """DeleteMedia

        Delete media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteMedia(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteMedia_with_http_info(id, **kwargs)  # noqa: E501

    def DeleteMedia_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Delete media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteMedia_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteMedia" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `DeleteMedia`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Media/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteMediaList(self, project, **kwargs):
        """DeleteMediaList

        Delete media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all media matching a query. It is  recommended to use a GET request first to check what is being deleted. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteMediaList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: List of integers identifying media.
        :param integer type: Unique integer identifying media type.
        :param character name: Name of the media to filter on.
        :param character md5: MD5 sum of the media file.
        :param character after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteMediaList_with_http_info(project, **kwargs)  # noqa: E501

    def DeleteMediaList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Delete media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all media matching a query. It is  recommended to use a GET request first to check what is being deleted.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteMediaList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: List of integers identifying media.
        :param integer type: Unique integer identifying media type.
        :param character name: Name of the media to filter on.
        :param character md5: MD5 sum of the media file.
        :param character after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.id',
            'type',
            'name',
            'md5',
            'after',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteMediaList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `DeleteMediaList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
            query_params.append(('md5', local_var_params['md5']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Medias/{project}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteMediaType(self, id, **kwargs):
        """DeleteMediaType

        Delete media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   Note that this will also delete any media associated with the media type. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteMediaType(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an media type. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteMediaType_with_http_info(id, **kwargs)  # noqa: E501

    def DeleteMediaType_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Delete media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   Note that this will also delete any media associated with the media type.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteMediaType_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an media type. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteMediaType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `DeleteMediaType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaType/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteMembership(self, id, **kwargs):
        """DeleteMembership

        Delete membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteMembership(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a membership. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteMembership_with_http_info(id, **kwargs)  # noqa: E501

    def DeleteMembership_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Delete membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteMembership_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a membership. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteMembership" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `DeleteMembership`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Membership/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteProject(self, id, **kwargs):
        """DeleteProject

        Delete project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   Only project owners may delete a project. Note that deleting a project will also delete all media and annotations within a project. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteProject(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a project. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteProject_with_http_info(id, **kwargs)  # noqa: E501

    def DeleteProject_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Delete project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   Only project owners may delete a project. Note that deleting a project will also delete all media and annotations within a project.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteProject_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a project. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteProject" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `DeleteProject`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Project/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteState(self, id, **kwargs):
        """DeleteState

        Delete state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteState(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteState_with_http_info(id, **kwargs)  # noqa: E501

    def DeleteState_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Delete state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteState_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteState" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `DeleteState`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/State/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteStateList(self, project, **kwargs):
        """DeleteStateList

        Delete state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all states matching a query. It is  recommended to use a GET request first to check what is being deleted. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteStateList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character media.query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param array[integer] media.id: Comma-separated list of media IDs.
        :param integer type: Unique integer identifying a annotation type.
        :param array[integer] version: List of integers representing versions to fetch
        :param integer modified: Whether to return original or modified annotations, 0 or 1.
        :param integer after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteStateList_with_http_info(project, **kwargs)  # noqa: E501

    def DeleteStateList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Delete state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all states matching a query. It is  recommended to use a GET request first to check what is being deleted.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteStateList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character media.query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param array[integer] media.id: Comma-separated list of media IDs.
        :param integer type: Unique integer identifying a annotation type.
        :param array[integer] version: List of integers representing versions to fetch
        :param integer modified: Whether to return original or modified annotations, 0 or 1.
        :param integer after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.query',
            'media.id',
            'type',
            'version',
            'modified',
            'after',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteStateList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `DeleteStateList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.query' in local_var_params and local_var_params['media.query'] is not None:  # noqa: E501
            query_params.append(('media_query', local_var_params['media.query']))  # noqa: E501
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'version' in local_var_params and local_var_params['version'] is not None:  # noqa: E501
            query_params.append(('version', local_var_params['version']))  # noqa: E501
            collection_formats['version'] = 'csv'  # noqa: E501
        if 'modified' in local_var_params and local_var_params['modified'] is not None:  # noqa: E501
            query_params.append(('modified', local_var_params['modified']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/States/{project}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteStateType(self, id, **kwargs):
        """DeleteStateType

        Delete state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   Note that this will also delete any states associated with the state type. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteStateType(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state type. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteStateType_with_http_info(id, **kwargs)  # noqa: E501

    def DeleteStateType_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Delete state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   Note that this will also delete any states associated with the state type.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteStateType_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state type. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteStateType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `DeleteStateType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/StateType/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteTemporaryFile(self, id, **kwargs):
        """DeleteTemporaryFile

        Delete temporary file.  Temporary files are files stored server side for a defined duration. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteTemporaryFile(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a temporary file. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteTemporaryFile_with_http_info(id, **kwargs)  # noqa: E501

    def DeleteTemporaryFile_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Delete temporary file.  Temporary files are files stored server side for a defined duration.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteTemporaryFile_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a temporary file. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteTemporaryFile" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `DeleteTemporaryFile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TemporaryFile/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteTemporaryFileList(self, project, **kwargs):
        """DeleteTemporaryFileList

        Delete temporary file list.  Temporary files are files stored server side for a defined duration.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteTemporaryFileList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param integer expired: If greater than 0 will return only expired files
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteTemporaryFileList_with_http_info(project, **kwargs)  # noqa: E501

    def DeleteTemporaryFileList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Delete temporary file list.  Temporary files are files stored server side for a defined duration.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteTemporaryFileList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param integer expired: If greater than 0 will return only expired files
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'expired'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteTemporaryFileList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `DeleteTemporaryFileList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'expired' in local_var_params and local_var_params['expired'] is not None:  # noqa: E501
            query_params.append(('expired', local_var_params['expired']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TemporaryFiles/{project}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def DeleteVersion(self, id, **kwargs):
        """DeleteVersion

        Delete version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.   Note that this will also delete any localizations or states associated with the deleted version. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteVersion(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a version. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.DeleteVersion_with_http_info(id, **kwargs)  # noqa: E501

    def DeleteVersion_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Delete version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.   Note that this will also delete any localizations or states associated with the deleted version.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.DeleteVersion_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a version. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method DeleteVersion" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `DeleteVersion`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Version/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetAlgorithmList(self, project, **kwargs):
        """GetAlgorithmList

        Get algorithms.  Algorithms must be registered to a project as an argo workflow. For  instructions on how to register an algorithm, see the documentation:   <https://github.com/cvisionai/tator/tree/master/examples/algorithms> 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetAlgorithmList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[Algorithm]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetAlgorithmList_with_http_info(project, **kwargs)  # noqa: E501

    def GetAlgorithmList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get algorithms.  Algorithms must be registered to a project as an argo workflow. For  instructions on how to register an algorithm, see the documentation:   <https://github.com/cvisionai/tator/tree/master/examples/algorithms>   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetAlgorithmList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[Algorithm]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetAlgorithmList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetAlgorithmList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Algorithms/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[Algorithm]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetAnalysisList(self, project, **kwargs):
        """GetAnalysisList

        Get analysis.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetAnalysisList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[Analysis]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetAnalysisList_with_http_info(project, **kwargs)  # noqa: E501

    def GetAnalysisList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get analysis.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetAnalysisList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[Analysis]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetAnalysisList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetAnalysisList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Analyses/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[Analysis]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetClip(self, id, frame.ranges, **kwargs):
        """GetClip

        Get video clip.  Facility to get a clip from the server. Returns a temporary file object that expires in 24 hours. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetClip(id, frame.ranges, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media object. (required)
        :param array[character] frame.ranges: Comma-seperated list of frame ranges to capture. (required)
        :param integer quality: Source resolution to use (default to highest quality)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.TemporaryFile`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetClip_with_http_info(id, frame.ranges, **kwargs)  # noqa: E501

    def GetClip_with_http_info(self, id, frame.ranges, **kwargs):  # noqa: E501
        """
        Get video clip.  Facility to get a clip from the server. Returns a temporary file object that expires in 24 hours.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetClip_with_http_info(id, frame.ranges, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media object. (required)
        :param array[character] frame.ranges: Comma-seperated list of frame ranges to capture. (required)
        :param integer quality: Source resolution to use (default to highest quality)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.TemporaryFile`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'frame.ranges',
            'quality'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetClip" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetClip`")  # noqa: E501
        # verify the required parameter 'frame.ranges' is set
        if self.api_client.client_side_validation and ('frame.ranges' not in local_var_params or  # noqa: E501
                                                        local_var_params['frame.ranges'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `frame.ranges` when calling `GetClip`")  # noqa: E501

        if self.api_client.client_side_validation and 'quality' in local_var_params and local_var_params['quality'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `quality` when calling `GetClip`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'frame.ranges' in local_var_params and local_var_params['frame.ranges'] is not None:  # noqa: E501
            query_params.append(('frameRanges', local_var_params['frame.ranges']))  # noqa: E501
            collection_formats['frameRanges'] = 'csv'  # noqa: E501
        if 'quality' in local_var_params and local_var_params['quality'] is not None:  # noqa: E501
            query_params.append(('quality', local_var_params['quality']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/GetClip/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TemporaryFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetFrame(self, id, **kwargs):
        """GetFrame

        Get frame(s) from a video.  Facility to get a frame(jpg/png) of a given video frame, returns a square tile of frames based on the input parameter. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetFrame(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media object. (required)
        :param array[integer] frames: Comma-seperated list of frames to capture.
        :param character tile: wxh, if not supplied is made as squarish as possible.
        :param character roi: w:h:x:y, optionally crop each frame to a given roi in relative coordinates.
        :param integer animate: If not tiling, animate each frame at a given fps in a gif.
        :param integer quality: Source resolution to use (default to highest quality)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.data.frame`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetFrame_with_http_info(id, **kwargs)  # noqa: E501

    def GetFrame_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get frame(s) from a video.  Facility to get a frame(jpg/png) of a given video frame, returns a square tile of frames based on the input parameter.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetFrame_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media object. (required)
        :param array[integer] frames: Comma-seperated list of frames to capture.
        :param character tile: wxh, if not supplied is made as squarish as possible.
        :param character roi: w:h:x:y, optionally crop each frame to a given roi in relative coordinates.
        :param integer animate: If not tiling, animate each frame at a given fps in a gif.
        :param integer quality: Source resolution to use (default to highest quality)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.data.frame`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'frames',
            'tile',
            'roi',
            'animate',
            'quality'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetFrame" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetFrame`")  # noqa: E501

        if self.api_client.client_side_validation and ('frames' in local_var_params and  # noqa: E501
                                                        len(local_var_params['frames']) > 32):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `frames` when calling `GetFrame`, length must be less than or equal to `32`")  # noqa: E501
        if self.api_client.client_side_validation and 'animate' in local_var_params and local_var_params['animate'] > 15:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `animate` when calling `GetFrame`, must be a value less than or equal to `15`")  # noqa: E501
        if self.api_client.client_side_validation and 'animate' in local_var_params and local_var_params['animate'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `animate` when calling `GetFrame`, must be a value greater than or equal to `0`")  # noqa: E501
        if self.api_client.client_side_validation and 'quality' in local_var_params and local_var_params['quality'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `quality` when calling `GetFrame`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'frames' in local_var_params and local_var_params['frames'] is not None:  # noqa: E501
            query_params.append(('frames', local_var_params['frames']))  # noqa: E501
            collection_formats['frames'] = 'csv'  # noqa: E501
        if 'tile' in local_var_params and local_var_params['tile'] is not None:  # noqa: E501
            query_params.append(('tile', local_var_params['tile']))  # noqa: E501
        if 'roi' in local_var_params and local_var_params['roi'] is not None:  # noqa: E501
            query_params.append(('roi', local_var_params['roi']))  # noqa: E501
        if 'animate' in local_var_params and local_var_params['animate'] is not None:  # noqa: E501
            query_params.append(('animate', local_var_params['animate']))  # noqa: E501
        if 'quality' in local_var_params and local_var_params['quality'] is not None:  # noqa: E501
            query_params.append(('quality', local_var_params['quality']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/GetFrame/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='data.frame',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetLeaf(self, id, **kwargs):
        """GetLeaf

        Get leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLeaf(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a leaf. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.Leaf`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetLeaf_with_http_info(id, **kwargs)  # noqa: E501

    def GetLeaf_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLeaf_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a leaf. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.Leaf`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetLeaf" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetLeaf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Leaf/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Leaf',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetLeafList(self, project, **kwargs):
        """GetLeafList

        Get leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLeafList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character ancestor: Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia).
        :param integer type: Unique integer identifying a leaf type.
        :param character name: Name of the leaf element.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[Leaf]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetLeafList_with_http_info(project, **kwargs)  # noqa: E501

    def GetLeafList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLeafList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character ancestor: Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia).
        :param integer type: Unique integer identifying a leaf type.
        :param character name: Name of the leaf element.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[Leaf]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'ancestor',
            'type',
            'name',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetLeafList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetLeafList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'ancestor' in local_var_params and local_var_params['ancestor'] is not None:  # noqa: E501
            query_params.append(('ancestor', local_var_params['ancestor']))  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Leaves/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[Leaf]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetLeafType(self, id, **kwargs):
        """GetLeafType

        Get leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLeafType(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an leaf type. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.LeafType`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetLeafType_with_http_info(id, **kwargs)  # noqa: E501

    def GetLeafType_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLeafType_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an leaf type. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.LeafType`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetLeafType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetLeafType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LeafType/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LeafType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetLeafTypeList(self, project, **kwargs):
        """GetLeafTypeList

        Get leaf type list.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLeafTypeList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[LeafType]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetLeafTypeList_with_http_info(project, **kwargs)  # noqa: E501

    def GetLeafTypeList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get leaf type list.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLeafTypeList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[LeafType]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetLeafTypeList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetLeafTypeList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LeafTypes/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[LeafType]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetLocalization(self, id, **kwargs):
        """GetLocalization

        Get localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLocalization(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a localization. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.Localization`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetLocalization_with_http_info(id, **kwargs)  # noqa: E501

    def GetLocalization_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLocalization_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a localization. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.Localization`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetLocalization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetLocalization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localization/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Localization',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetLocalizationList(self, project, **kwargs):
        """GetLocalizationList

        Get localization list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLocalizationList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character media.query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param array[integer] media.id: Comma-separated list of media IDs.
        :param integer type: Unique integer identifying a annotation type.
        :param array[integer] version: List of integers representing versions to fetch
        :param integer modified: Whether to return original or modified annotations, 0 or 1.
        :param integer after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param integer exclude.parents: If a clone is present, do not send parent. (0 or 1)
        :param integer frame: Frame number of this localization if it is in a video.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[Localization]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetLocalizationList_with_http_info(project, **kwargs)  # noqa: E501

    def GetLocalizationList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get localization list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLocalizationList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character media.query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param array[integer] media.id: Comma-separated list of media IDs.
        :param integer type: Unique integer identifying a annotation type.
        :param array[integer] version: List of integers representing versions to fetch
        :param integer modified: Whether to return original or modified annotations, 0 or 1.
        :param integer after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param integer exclude.parents: If a clone is present, do not send parent. (0 or 1)
        :param integer frame: Frame number of this localization if it is in a video.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[Localization]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.query',
            'media.id',
            'type',
            'version',
            'modified',
            'after',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop',
            'exclude.parents',
            'frame'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetLocalizationList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetLocalizationList`")  # noqa: E501

        if self.api_client.client_side_validation and 'exclude.parents' in local_var_params and local_var_params['exclude.parents'] > 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `exclude.parents` when calling `GetLocalizationList`, must be a value less than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'exclude.parents' in local_var_params and local_var_params['exclude.parents'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `exclude.parents` when calling `GetLocalizationList`, must be a value greater than or equal to `0`")  # noqa: E501
        if self.api_client.client_side_validation and 'frame' in local_var_params and local_var_params['frame'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `frame` when calling `GetLocalizationList`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.query' in local_var_params and local_var_params['media.query'] is not None:  # noqa: E501
            query_params.append(('media_query', local_var_params['media.query']))  # noqa: E501
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'version' in local_var_params and local_var_params['version'] is not None:  # noqa: E501
            query_params.append(('version', local_var_params['version']))  # noqa: E501
            collection_formats['version'] = 'csv'  # noqa: E501
        if 'modified' in local_var_params and local_var_params['modified'] is not None:  # noqa: E501
            query_params.append(('modified', local_var_params['modified']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501
        if 'exclude.parents' in local_var_params and local_var_params['exclude.parents'] is not None:  # noqa: E501
            query_params.append(('excludeParents', local_var_params['exclude.parents']))  # noqa: E501
        if 'frame' in local_var_params and local_var_params['frame'] is not None:  # noqa: E501
            query_params.append(('frame', local_var_params['frame']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localizations/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[Localization]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetLocalizationType(self, id, **kwargs):
        """GetLocalizationType

        Get localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLocalizationType(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an localization type. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.LocalizationType`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetLocalizationType_with_http_info(id, **kwargs)  # noqa: E501

    def GetLocalizationType_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLocalizationType_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an localization type. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.LocalizationType`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetLocalizationType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetLocalizationType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationType/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LocalizationType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetLocalizationTypeList(self, project, **kwargs):
        """GetLocalizationTypeList

        Get localization type list.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLocalizationTypeList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: List of unique integers identifying a media.
        :param integer type: Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[LocalizationType]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetLocalizationTypeList_with_http_info(project, **kwargs)  # noqa: E501

    def GetLocalizationTypeList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get localization type list.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetLocalizationTypeList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: List of unique integers identifying a media.
        :param integer type: Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[LocalizationType]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.id',
            'type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetLocalizationTypeList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetLocalizationTypeList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationTypes/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[LocalizationType]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetMedia(self, id, **kwargs):
        """GetMedia

        Get media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMedia(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.Media`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetMedia_with_http_info(id, **kwargs)  # noqa: E501

    def GetMedia_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMedia_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.Media`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetMedia" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetMedia`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Media/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Media',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetMediaList(self, project, **kwargs):
        """GetMediaList

        Get media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMediaList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: List of integers identifying media.
        :param integer type: Unique integer identifying media type.
        :param character name: Name of the media to filter on.
        :param character md5: MD5 sum of the media file.
        :param character after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[Media]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetMediaList_with_http_info(project, **kwargs)  # noqa: E501

    def GetMediaList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMediaList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: List of integers identifying media.
        :param integer type: Unique integer identifying media type.
        :param character name: Name of the media to filter on.
        :param character md5: MD5 sum of the media file.
        :param character after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[Media]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.id',
            'type',
            'name',
            'md5',
            'after',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetMediaList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetMediaList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
            query_params.append(('md5', local_var_params['md5']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Medias/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[Media]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetMediaNext(self, id, **kwargs):
        """GetMediaNext

        Retrieve ID of next media in a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the next media ID from the media passed as a path parameter. This allows iteration through a media list without serializing the entire list, which may be large. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMediaNext(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media object. (required)
        :param array[integer] media.id: List of integers identifying media.
        :param integer type: Unique integer identifying media type.
        :param character name: Name of the media to filter on.
        :param character md5: MD5 sum of the media file.
        :param character after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MediaNext`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetMediaNext_with_http_info(id, **kwargs)  # noqa: E501

    def GetMediaNext_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Retrieve ID of next media in a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the next media ID from the media passed as a path parameter. This allows iteration through a media list without serializing the entire list, which may be large.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMediaNext_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media object. (required)
        :param array[integer] media.id: List of integers identifying media.
        :param integer type: Unique integer identifying media type.
        :param character name: Name of the media to filter on.
        :param character md5: MD5 sum of the media file.
        :param character after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MediaNext`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'media.id',
            'type',
            'name',
            'md5',
            'after',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetMediaNext" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetMediaNext`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
            query_params.append(('md5', local_var_params['md5']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaNext/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MediaNext',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetMediaPrev(self, id, **kwargs):
        """GetMediaPrev

        Retrieve ID of previous media in a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the previous media ID from the media passed as a path parameter. This  allows iteration through a media list without serializing the entire list, which may be  large. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMediaPrev(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media object. (required)
        :param array[integer] media.id: List of integers identifying media.
        :param integer type: Unique integer identifying media type.
        :param character name: Name of the media to filter on.
        :param character md5: MD5 sum of the media file.
        :param character after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MediaPrev`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetMediaPrev_with_http_info(id, **kwargs)  # noqa: E501

    def GetMediaPrev_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Retrieve ID of previous media in a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the previous media ID from the media passed as a path parameter. This  allows iteration through a media list without serializing the entire list, which may be  large.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMediaPrev_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media object. (required)
        :param array[integer] media.id: List of integers identifying media.
        :param integer type: Unique integer identifying media type.
        :param character name: Name of the media to filter on.
        :param character md5: MD5 sum of the media file.
        :param character after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MediaPrev`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'media.id',
            'type',
            'name',
            'md5',
            'after',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetMediaPrev" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetMediaPrev`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
            query_params.append(('md5', local_var_params['md5']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaPrev/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MediaPrev',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetMediaSections(self, project, **kwargs):
        """GetMediaSections

        Retrieve media counts by section.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the number of images and videos per sections. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMediaSections(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: List of integers identifying media.
        :param integer type: Unique integer identifying media type.
        :param character name: Name of the media to filter on.
        :param character md5: MD5 sum of the media file.
        :param character after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.map(object)`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetMediaSections_with_http_info(project, **kwargs)  # noqa: E501

    def GetMediaSections_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Retrieve media counts by section.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the number of images and videos per sections.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMediaSections_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: List of integers identifying media.
        :param integer type: Unique integer identifying media type.
        :param character name: Name of the media to filter on.
        :param character md5: MD5 sum of the media file.
        :param character after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.map(object)`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.id',
            'type',
            'name',
            'md5',
            'after',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetMediaSections" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetMediaSections`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
            query_params.append(('md5', local_var_params['md5']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaSections/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='map(object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetMediaType(self, id, **kwargs):
        """GetMediaType

        Get media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMediaType(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an media type. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MediaType`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetMediaType_with_http_info(id, **kwargs)  # noqa: E501

    def GetMediaType_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMediaType_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an media type. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MediaType`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetMediaType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetMediaType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaType/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MediaType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetMediaTypeList(self, project, **kwargs):
        """GetMediaTypeList

        Get media type list.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMediaTypeList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[MediaType]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetMediaTypeList_with_http_info(project, **kwargs)  # noqa: E501

    def GetMediaTypeList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get media type list.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMediaTypeList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[MediaType]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetMediaTypeList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetMediaTypeList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaTypes/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[MediaType]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetMembership(self, id, **kwargs):
        """GetMembership

        Get membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMembership(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a membership. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.Membership`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetMembership_with_http_info(id, **kwargs)  # noqa: E501

    def GetMembership_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMembership_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a membership. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.Membership`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetMembership" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetMembership`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Membership/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Membership',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetMembershipList(self, project, **kwargs):
        """GetMembershipList

        Get membership list.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMembershipList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[Membership]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetMembershipList_with_http_info(project, **kwargs)  # noqa: E501

    def GetMembershipList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get membership list.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetMembershipList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[Membership]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetMembershipList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetMembershipList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Memberships/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[Membership]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetProject(self, id, **kwargs):
        """GetProject

        Get project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetProject(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a project. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.Project`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetProject_with_http_info(id, **kwargs)  # noqa: E501

    def GetProject_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetProject_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a project. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.Project`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetProject" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetProject`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Project/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Project',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetProjectList(self, **kwargs):
        """GetProjectList

        Get project list.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   Returns all projects that a user has access to.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetProjectList(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[Project]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetProjectList_with_http_info(**kwargs)  # noqa: E501

    def GetProjectList_with_http_info(self, **kwargs):  # noqa: E501
        """
        Get project list.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   Returns all projects that a user has access to.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetProjectList_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[Project]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetProjectList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[Project]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetSectionAnalysis(self, project, **kwargs):
        """GetSectionAnalysis

        Retrieve analysis results for a media list.  This endpoint uses objects created with the `Analysis` endpoint to perform analysis on filtered media lists. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetSectionAnalysis(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: Unique integer identifying a media. Use this to do analyis on a single file instead of sections.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.map(AnyType)`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetSectionAnalysis_with_http_info(project, **kwargs)  # noqa: E501

    def GetSectionAnalysis_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Retrieve analysis results for a media list.  This endpoint uses objects created with the `Analysis` endpoint to perform analysis on filtered media lists.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetSectionAnalysis_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: Unique integer identifying a media. Use this to do analyis on a single file instead of sections.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.map(AnyType)`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.id',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetSectionAnalysis" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetSectionAnalysis`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/SectionAnalysis/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='map(AnyType)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetState(self, id, **kwargs):
        """GetState

        Get state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetState(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.State`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetState_with_http_info(id, **kwargs)  # noqa: E501

    def GetState_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetState_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.State`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetState" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetState`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/State/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='State',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetStateGraphic(self, id, **kwargs):
        """GetStateGraphic

         Get frame(s) of a given localization-associated state.  Use the mode argument to control whether it is an animated gif or a tiled jpg. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetStateGraphic(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state. (required)
        :param character mode: Whether to animate or tile.
        :param numeric fps: Frame rate if `mode` is `animate`.
        :param character force.scale: wxh to force each tile prior to stich
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.data.frame`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetStateGraphic_with_http_info(id, **kwargs)  # noqa: E501

    def GetStateGraphic_with_http_info(self, id, **kwargs):  # noqa: E501
        """
         Get frame(s) of a given localization-associated state.  Use the mode argument to control whether it is an animated gif or a tiled jpg.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetStateGraphic_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state. (required)
        :param character mode: Whether to animate or tile.
        :param numeric fps: Frame rate if `mode` is `animate`.
        :param character force.scale: wxh to force each tile prior to stich
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.data.frame`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'mode',
            'fps',
            'force.scale'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetStateGraphic" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetStateGraphic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'mode' in local_var_params and local_var_params['mode'] is not None:  # noqa: E501
            query_params.append(('mode', local_var_params['mode']))  # noqa: E501
        if 'fps' in local_var_params and local_var_params['fps'] is not None:  # noqa: E501
            query_params.append(('fps', local_var_params['fps']))  # noqa: E501
        if 'force.scale' in local_var_params and local_var_params['force.scale'] is not None:  # noqa: E501
            query_params.append(('forceScale', local_var_params['force.scale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/StateGraphic/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='data.frame',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetStateList(self, project, **kwargs):
        """GetStateList

        Get state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetStateList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character media.query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param array[integer] media.id: Comma-separated list of media IDs.
        :param integer type: Unique integer identifying a annotation type.
        :param array[integer] version: List of integers representing versions to fetch
        :param integer modified: Whether to return original or modified annotations, 0 or 1.
        :param integer after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[State]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetStateList_with_http_info(project, **kwargs)  # noqa: E501

    def GetStateList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetStateList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character media.query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param array[integer] media.id: Comma-separated list of media IDs.
        :param integer type: Unique integer identifying a annotation type.
        :param array[integer] version: List of integers representing versions to fetch
        :param integer modified: Whether to return original or modified annotations, 0 or 1.
        :param integer after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[State]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.query',
            'media.id',
            'type',
            'version',
            'modified',
            'after',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetStateList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetStateList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.query' in local_var_params and local_var_params['media.query'] is not None:  # noqa: E501
            query_params.append(('media_query', local_var_params['media.query']))  # noqa: E501
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'version' in local_var_params and local_var_params['version'] is not None:  # noqa: E501
            query_params.append(('version', local_var_params['version']))  # noqa: E501
            collection_formats['version'] = 'csv'  # noqa: E501
        if 'modified' in local_var_params and local_var_params['modified'] is not None:  # noqa: E501
            query_params.append(('modified', local_var_params['modified']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/States/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[State]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetStateType(self, id, **kwargs):
        """GetStateType

        Get state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetStateType(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state type. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.StateType`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetStateType_with_http_info(id, **kwargs)  # noqa: E501

    def GetStateType_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetStateType_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state type. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.StateType`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetStateType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetStateType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/StateType/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StateType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetStateTypeList(self, project, **kwargs):
        """GetStateTypeList

        Get state type list.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetStateTypeList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: List of unique integers identifying a media.
        :param integer type: Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[StateType]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetStateTypeList_with_http_info(project, **kwargs)  # noqa: E501

    def GetStateTypeList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get state type list.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetStateTypeList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: List of unique integers identifying a media.
        :param integer type: Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[StateType]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.id',
            'type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetStateTypeList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetStateTypeList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/StateTypes/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[StateType]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetTemporaryFile(self, id, **kwargs):
        """GetTemporaryFile

        Get temporary file.  Temporary files are files stored server side for a defined duration. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetTemporaryFile(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a temporary file. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.TemporaryFile`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetTemporaryFile_with_http_info(id, **kwargs)  # noqa: E501

    def GetTemporaryFile_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get temporary file.  Temporary files are files stored server side for a defined duration.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetTemporaryFile_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a temporary file. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.TemporaryFile`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetTemporaryFile" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetTemporaryFile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TemporaryFile/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TemporaryFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetTemporaryFileList(self, project, **kwargs):
        """GetTemporaryFileList

        Get temporary file list.  Temporary files are files stored server side for a defined duration.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetTemporaryFileList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param integer expired: If greater than 0 will return only expired files
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[TemporaryFile]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetTemporaryFileList_with_http_info(project, **kwargs)  # noqa: E501

    def GetTemporaryFileList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get temporary file list.  Temporary files are files stored server side for a defined duration.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetTemporaryFileList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param integer expired: If greater than 0 will return only expired files
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[TemporaryFile]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'expired'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetTemporaryFileList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetTemporaryFileList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'expired' in local_var_params and local_var_params['expired'] is not None:  # noqa: E501
            query_params.append(('expired', local_var_params['expired']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TemporaryFiles/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[TemporaryFile]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetUser(self, id, **kwargs):
        """GetUser

        Get user.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetUser(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a localization association. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.User`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetUser_with_http_info(id, **kwargs)  # noqa: E501

    def GetUser_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetUser_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a localization association. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.User`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetUser" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetUser`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/User/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetVersion(self, id, **kwargs):
        """GetVersion

        Get version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetVersion(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a version. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.Version`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetVersion_with_http_info(id, **kwargs)  # noqa: E501

    def GetVersion_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Get version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetVersion_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a version. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.Version`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetVersion" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `GetVersion`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Version/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Version',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def GetVersionList(self, project, **kwargs):
        """GetVersionList

        Get version list.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetVersionList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param integer media.id: Unique integer identifying a media.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[Version]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.GetVersionList_with_http_info(project, **kwargs)  # noqa: E501

    def GetVersionList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Get version list.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.GetVersionList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param integer media.id: Unique integer identifying a media.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[Version]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method GetVersionList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `GetVersionList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Versions/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[Version]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def LeafSuggestion(self, project, ancestor, query, **kwargs):
        """LeafSuggestion

        Get list of autocomplete suggestions.  This endpoint is compatible with devbridge suggestion format. It performs a glob search on leaf objects in the project.  <https://github.com/kraaden/autocomplete> 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.LeafSuggestion(project, ancestor, query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character ancestor: Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia). (required)
        :param character query: String to search for matching names. (required)
        :param integer min.level: Integer specifying level of results that may be returned. For example, 2 refers to grandchildren of the level specified by the `ancestor` parameter.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.array[LeafSuggestion]`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.LeafSuggestion_with_http_info(project, ancestor, query, **kwargs)  # noqa: E501

    def LeafSuggestion_with_http_info(self, project, ancestor, query, **kwargs):  # noqa: E501
        """
        Get list of autocomplete suggestions.  This endpoint is compatible with devbridge suggestion format. It performs a glob search on leaf objects in the project.  <https://github.com/kraaden/autocomplete>   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.LeafSuggestion_with_http_info(project, ancestor, query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character ancestor: Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia). (required)
        :param character query: String to search for matching names. (required)
        :param integer min.level: Integer specifying level of results that may be returned. For example, 2 refers to grandchildren of the level specified by the `ancestor` parameter.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.array[LeafSuggestion]`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'ancestor',
            'query',
            'min.level'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method LeafSuggestion" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `LeafSuggestion`")  # noqa: E501
        # verify the required parameter 'ancestor' is set
        if self.api_client.client_side_validation and ('ancestor' not in local_var_params or  # noqa: E501
                                                        local_var_params['ancestor'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `ancestor` when calling `LeafSuggestion`")  # noqa: E501
        # verify the required parameter 'query' is set
        if self.api_client.client_side_validation and ('query' not in local_var_params or  # noqa: E501
                                                        local_var_params['query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `query` when calling `LeafSuggestion`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501
        if 'ancestor' in local_var_params:
            path_params['ancestor'] = local_var_params['ancestor']  # noqa: E501

        query_params = []
        if 'min.level' in local_var_params and local_var_params['min.level'] is not None:  # noqa: E501
            query_params.append(('minLevel', local_var_params['min.level']))  # noqa: E501
        if 'query' in local_var_params and local_var_params['query'] is not None:  # noqa: E501
            query_params.append(('query', local_var_params['query']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Leaves/Suggestion/{ancestor}/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='array[LeafSuggestion]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Notify(self, **kwargs):
        """Notify

        Send a notification to administrators.  Uses the Slack API to send a notification to system administrators. This endpoint can only be used by system administrators and must be configured in a Tator deployment's settings. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.Notify(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NotifySpec notify.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.Notify_with_http_info(**kwargs)  # noqa: E501

    def Notify_with_http_info(self, **kwargs):  # noqa: E501
        """
        Send a notification to administrators.  Uses the Slack API to send a notification to system administrators. This endpoint can only be used by system administrators and must be configured in a Tator deployment's settings.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.Notify_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NotifySpec notify.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'notify.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Notify" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'notify.spec' in local_var_params:
            body_params = local_var_params['notify.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Notify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Progress(self, project, **kwargs):
        """Progress

        Broadcast progress update.  Progress messages are sent in the web UI via WebSocket, and are displayed as progress bars associated with individual media files and as a summary in the webpage header. All members of a project can see progress bars from uploads and background jobs initiated by other users within the project. This endpoint accepts an array of messages, allowing for progress messages to be batched into a single request. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.Progress(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[ProgressSpec] progress.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.Progress_with_http_info(project, **kwargs)  # noqa: E501

    def Progress_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Broadcast progress update.  Progress messages are sent in the web UI via WebSocket, and are displayed as progress bars associated with individual media files and as a summary in the webpage header. All members of a project can see progress bars from uploads and background jobs initiated by other users within the project. This endpoint accepts an array of messages, allowing for progress messages to be batched into a single request.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.Progress_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[ProgressSpec] progress.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'progress.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Progress" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `Progress`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'progress.spec' in local_var_params:
            body_params = local_var_params['progress.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Progress/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def SaveImage(self, project, **kwargs):
        """SaveImage

        Saves an uploaded image.  Media is uploaded via tus, a separate mechanism from the REST API. Once an image upload is complete, the image must be saved to the database using this endpoint. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.SaveImage(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param ImageSpec image.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.SaveImage_with_http_info(project, **kwargs)  # noqa: E501

    def SaveImage_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Saves an uploaded image.  Media is uploaded via tus, a separate mechanism from the REST API. Once an image upload is complete, the image must be saved to the database using this endpoint.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.SaveImage_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param ImageSpec image.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'image.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method SaveImage" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `SaveImage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'image.spec' in local_var_params:
            body_params = local_var_params['image.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/SaveImage/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def SaveVideo(self, project, **kwargs):
        """SaveVideo

        Saves a transcoded video.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. To launch a transcode on raw uploaded video, use the `Transcode` endpoint, which will create an Argo workflow to perform the transcode and save the video using this endpoint; no further REST calls are required. However, if you would like to perform transcodes locally, this endpoint enables that. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.SaveVideo(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param VideoSpec video.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.CreateResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.SaveVideo_with_http_info(project, **kwargs)  # noqa: E501

    def SaveVideo_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Saves a transcoded video.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. To launch a transcode on raw uploaded video, use the `Transcode` endpoint, which will create an Argo workflow to perform the transcode and save the video using this endpoint; no further REST calls are required. However, if you would like to perform transcodes locally, this endpoint enables that.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.SaveVideo_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param VideoSpec video.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.CreateResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'video.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method SaveVideo" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `SaveVideo`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'video.spec' in local_var_params:
            body_params = local_var_params['video.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/SaveVideo/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Transcode(self, project, **kwargs):
        """Transcode

        Start a transcode.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. This endpoint launches a transcode on raw uploaded video by creating an Argo workflow. The workflow will download the uploaded raw video, transcode it to the proper format, upload the transcoded video, and save the video using the  `SaveVideo` endpoint.  Note that the raw video must be uploaded first via tus, which is a separate mechanism  from the REST API. This endpoint requires a group and run UUID associated with this  upload. If no progress messages were generated during upload, then the group and run  UUIDs can be newly generated.  Transcodes may be cancelled via the `Job` or `JobGroup` endpoints. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.Transcode(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param TranscodeSpec transcode.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.Transcode`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.Transcode_with_http_info(project, **kwargs)  # noqa: E501

    def Transcode_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Start a transcode.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. This endpoint launches a transcode on raw uploaded video by creating an Argo workflow. The workflow will download the uploaded raw video, transcode it to the proper format, upload the transcoded video, and save the video using the  `SaveVideo` endpoint.  Note that the raw video must be uploaded first via tus, which is a separate mechanism  from the REST API. This endpoint requires a group and run UUID associated with this  upload. If no progress messages were generated during upload, then the group and run  UUIDs can be newly generated.  Transcodes may be cancelled via the `Job` or `JobGroup` endpoints.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.Transcode_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param TranscodeSpec transcode.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.Transcode`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'transcode.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Transcode" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `Transcode`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transcode.spec' in local_var_params:
            body_params = local_var_params['transcode.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Transcode/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Transcode',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateLeaf(self, id, **kwargs):
        """UpdateLeaf

        Update leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateLeaf(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a leaf. (required)
        :param LeafUpdate leaf.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateLeaf_with_http_info(id, **kwargs)  # noqa: E501

    def UpdateLeaf_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Update leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateLeaf_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a leaf. (required)
        :param LeafUpdate leaf.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'leaf.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateLeaf" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `UpdateLeaf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'leaf.update' in local_var_params:
            body_params = local_var_params['leaf.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Leaf/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateLeafList(self, project, **kwargs):
        """UpdateLeafList

        Update leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method does a bulk update on all leaves matching a query. Only  user-defined attributes may be bulk updated. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateLeafList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character ancestor: Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia).
        :param integer type: Unique integer identifying a leaf type.
        :param character name: Name of the leaf element.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param AttributeBulkUpdate attribute.bulk.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateLeafList_with_http_info(project, **kwargs)  # noqa: E501

    def UpdateLeafList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Update leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method does a bulk update on all leaves matching a query. Only  user-defined attributes may be bulk updated.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateLeafList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character ancestor: Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia).
        :param integer type: Unique integer identifying a leaf type.
        :param character name: Name of the leaf element.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param AttributeBulkUpdate attribute.bulk.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'ancestor',
            'type',
            'name',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop',
            'attribute.bulk.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateLeafList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `UpdateLeafList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'ancestor' in local_var_params and local_var_params['ancestor'] is not None:  # noqa: E501
            query_params.append(('ancestor', local_var_params['ancestor']))  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'attribute.bulk.update' in local_var_params:
            body_params = local_var_params['attribute.bulk.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Leaves/{project}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateLeafType(self, id, **kwargs):
        """UpdateLeafType

        Update leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateLeafType(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an leaf type. (required)
        :param LeafTypeUpdate leaf.type.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateLeafType_with_http_info(id, **kwargs)  # noqa: E501

    def UpdateLeafType_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Update leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateLeafType_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an leaf type. (required)
        :param LeafTypeUpdate leaf.type.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'leaf.type.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateLeafType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `UpdateLeafType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'leaf.type.update' in local_var_params:
            body_params = local_var_params['leaf.type.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LeafType/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateLocalization(self, id, **kwargs):
        """UpdateLocalization

        Update localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateLocalization(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a localization. (required)
        :param LocalizationUpdate localization.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateLocalization_with_http_info(id, **kwargs)  # noqa: E501

    def UpdateLocalization_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Update localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateLocalization_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a localization. (required)
        :param LocalizationUpdate localization.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'localization.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateLocalization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `UpdateLocalization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'localization.update' in local_var_params:
            body_params = local_var_params['localization.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localization/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateLocalizationList(self, project, **kwargs):
        """UpdateLocalizationList

        Update localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all localizations matching a query. Only  user-defined attributes may be bulk updated. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateLocalizationList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character media.query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param array[integer] media.id: Comma-separated list of media IDs.
        :param integer type: Unique integer identifying a annotation type.
        :param array[integer] version: List of integers representing versions to fetch
        :param integer modified: Whether to return original or modified annotations, 0 or 1.
        :param integer after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param integer exclude.parents: If a clone is present, do not send parent. (0 or 1)
        :param integer frame: Frame number of this localization if it is in a video.
        :param AttributeBulkUpdate attribute.bulk.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateLocalizationList_with_http_info(project, **kwargs)  # noqa: E501

    def UpdateLocalizationList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Update localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all localizations matching a query. Only  user-defined attributes may be bulk updated.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateLocalizationList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character media.query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param array[integer] media.id: Comma-separated list of media IDs.
        :param integer type: Unique integer identifying a annotation type.
        :param array[integer] version: List of integers representing versions to fetch
        :param integer modified: Whether to return original or modified annotations, 0 or 1.
        :param integer after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param integer exclude.parents: If a clone is present, do not send parent. (0 or 1)
        :param integer frame: Frame number of this localization if it is in a video.
        :param AttributeBulkUpdate attribute.bulk.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.query',
            'media.id',
            'type',
            'version',
            'modified',
            'after',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop',
            'exclude.parents',
            'frame',
            'attribute.bulk.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateLocalizationList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `UpdateLocalizationList`")  # noqa: E501

        if self.api_client.client_side_validation and 'exclude.parents' in local_var_params and local_var_params['exclude.parents'] > 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `exclude.parents` when calling `UpdateLocalizationList`, must be a value less than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'exclude.parents' in local_var_params and local_var_params['exclude.parents'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `exclude.parents` when calling `UpdateLocalizationList`, must be a value greater than or equal to `0`")  # noqa: E501
        if self.api_client.client_side_validation and 'frame' in local_var_params and local_var_params['frame'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `frame` when calling `UpdateLocalizationList`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.query' in local_var_params and local_var_params['media.query'] is not None:  # noqa: E501
            query_params.append(('media_query', local_var_params['media.query']))  # noqa: E501
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'version' in local_var_params and local_var_params['version'] is not None:  # noqa: E501
            query_params.append(('version', local_var_params['version']))  # noqa: E501
            collection_formats['version'] = 'csv'  # noqa: E501
        if 'modified' in local_var_params and local_var_params['modified'] is not None:  # noqa: E501
            query_params.append(('modified', local_var_params['modified']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501
        if 'exclude.parents' in local_var_params and local_var_params['exclude.parents'] is not None:  # noqa: E501
            query_params.append(('excludeParents', local_var_params['exclude.parents']))  # noqa: E501
        if 'frame' in local_var_params and local_var_params['frame'] is not None:  # noqa: E501
            query_params.append(('frame', local_var_params['frame']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'attribute.bulk.update' in local_var_params:
            body_params = local_var_params['attribute.bulk.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localizations/{project}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateLocalizationType(self, id, **kwargs):
        """UpdateLocalizationType

        Update localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateLocalizationType(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an localization type. (required)
        :param LocalizationTypeUpdate localization.type.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateLocalizationType_with_http_info(id, **kwargs)  # noqa: E501

    def UpdateLocalizationType_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Update localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateLocalizationType_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an localization type. (required)
        :param LocalizationTypeUpdate localization.type.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'localization.type.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateLocalizationType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `UpdateLocalizationType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'localization.type.update' in local_var_params:
            body_params = local_var_params['localization.type.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationType/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateMedia(self, id, **kwargs):
        """UpdateMedia

        Update media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateMedia(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media. (required)
        :param MediaUpdate media.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateMedia_with_http_info(id, **kwargs)  # noqa: E501

    def UpdateMedia_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Update media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateMedia_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a media. (required)
        :param MediaUpdate media.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'media.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateMedia" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `UpdateMedia`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'media.update' in local_var_params:
            body_params = local_var_params['media.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Media/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateMediaList(self, project, **kwargs):
        """UpdateMediaList

        Update media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all media matching a query. Only  user-defined attributes may be bulk updated. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateMediaList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: List of integers identifying media.
        :param integer type: Unique integer identifying media type.
        :param character name: Name of the media to filter on.
        :param character md5: MD5 sum of the media file.
        :param character after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param AttributeBulkUpdate attribute.bulk.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateMediaList_with_http_info(project, **kwargs)  # noqa: E501

    def UpdateMediaList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Update media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all media matching a query. Only  user-defined attributes may be bulk updated.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateMediaList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param array[integer] media.id: List of integers identifying media.
        :param integer type: Unique integer identifying media type.
        :param character name: Name of the media to filter on.
        :param character md5: MD5 sum of the media file.
        :param character after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param AttributeBulkUpdate attribute.bulk.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.id',
            'type',
            'name',
            'md5',
            'after',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop',
            'attribute.bulk.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateMediaList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `UpdateMediaList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'md5' in local_var_params and local_var_params['md5'] is not None:  # noqa: E501
            query_params.append(('md5', local_var_params['md5']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'attribute.bulk.update' in local_var_params:
            body_params = local_var_params['attribute.bulk.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Medias/{project}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateMediaType(self, id, **kwargs):
        """UpdateMediaType

        Update media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateMediaType(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an media type. (required)
        :param MediaTypeUpdate media.type.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateMediaType_with_http_info(id, **kwargs)  # noqa: E501

    def UpdateMediaType_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Update media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateMediaType_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying an media type. (required)
        :param MediaTypeUpdate media.type.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'media.type.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateMediaType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `UpdateMediaType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'media.type.update' in local_var_params:
            body_params = local_var_params['media.type.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaType/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateMembership(self, id, **kwargs):
        """UpdateMembership

        Update membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateMembership(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a membership. (required)
        :param MembershipUpdate membership.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateMembership_with_http_info(id, **kwargs)  # noqa: E501

    def UpdateMembership_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Update membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateMembership_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a membership. (required)
        :param MembershipUpdate membership.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'membership.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateMembership" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `UpdateMembership`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'membership.update' in local_var_params:
            body_params = local_var_params['membership.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Membership/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateProject(self, id, **kwargs):
        """UpdateProject

        Update project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateProject(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a project. (required)
        :param ProjectSpec project.spec:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateProject_with_http_info(id, **kwargs)  # noqa: E501

    def UpdateProject_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Update project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateProject_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a project. (required)
        :param ProjectSpec project.spec:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'project.spec'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateProject" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `UpdateProject`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project.spec' in local_var_params:
            body_params = local_var_params['project.spec']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Project/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateState(self, id, **kwargs):
        """UpdateState

        Update state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateState(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state. (required)
        :param StateUpdate state.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateState_with_http_info(id, **kwargs)  # noqa: E501

    def UpdateState_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Update state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateState_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state. (required)
        :param StateUpdate state.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'state.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateState" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `UpdateState`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'state.update' in local_var_params:
            body_params = local_var_params['state.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/State/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateStateList(self, project, **kwargs):
        """UpdateStateList

        Update state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all states matching a query. Only  user-defined attributes may be bulk updated. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateStateList(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character media.query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param array[integer] media.id: Comma-separated list of media IDs.
        :param integer type: Unique integer identifying a annotation type.
        :param array[integer] version: List of integers representing versions to fetch
        :param integer modified: Whether to return original or modified annotations, 0 or 1.
        :param integer after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param AttributeBulkUpdate attribute.bulk.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateStateList_with_http_info(project, **kwargs)  # noqa: E501

    def UpdateStateList_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Update state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all states matching a query. Only  user-defined attributes may be bulk updated.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateStateList_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param character media.query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param array[integer] media.id: Comma-separated list of media IDs.
        :param integer type: Unique integer identifying a annotation type.
        :param array[integer] version: List of integers representing versions to fetch
        :param integer modified: Whether to return original or modified annotations, 0 or 1.
        :param integer after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param character search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param character attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param character attribute.distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param character attribute.null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param character operation: Set to \"count\" to return a count of objects instead of the objects.
        :param integer start: Pagination start index. Index of the first item in a larger list to return.
        :param integer stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :param AttributeBulkUpdate attribute.bulk.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'media.query',
            'media.id',
            'type',
            'version',
            'modified',
            'after',
            'search',
            'attribute',
            'attribute.lt',
            'attribute.lte',
            'attribute.gt',
            'attribute.gte',
            'attribute.contains',
            'attribute.distance',
            'attribute.null',
            'operation',
            'start',
            'stop',
            'attribute.bulk.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateStateList" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `UpdateStateList`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []
        if 'media.query' in local_var_params and local_var_params['media.query'] is not None:  # noqa: E501
            query_params.append(('media_query', local_var_params['media.query']))  # noqa: E501
        if 'media.id' in local_var_params and local_var_params['media.id'] is not None:  # noqa: E501
            query_params.append(('media_id', local_var_params['media.id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'version' in local_var_params and local_var_params['version'] is not None:  # noqa: E501
            query_params.append(('version', local_var_params['version']))  # noqa: E501
            collection_formats['version'] = 'csv'  # noqa: E501
        if 'modified' in local_var_params and local_var_params['modified'] is not None:  # noqa: E501
            query_params.append(('modified', local_var_params['modified']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'search' in local_var_params and local_var_params['search'] is not None:  # noqa: E501
            query_params.append(('search', local_var_params['search']))  # noqa: E501
        if 'attribute' in local_var_params and local_var_params['attribute'] is not None:  # noqa: E501
            query_params.append(('attribute', local_var_params['attribute']))  # noqa: E501
        if 'attribute.lt' in local_var_params and local_var_params['attribute.lt'] is not None:  # noqa: E501
            query_params.append(('attribute_lt', local_var_params['attribute.lt']))  # noqa: E501
        if 'attribute.lte' in local_var_params and local_var_params['attribute.lte'] is not None:  # noqa: E501
            query_params.append(('attribute_lte', local_var_params['attribute.lte']))  # noqa: E501
        if 'attribute.gt' in local_var_params and local_var_params['attribute.gt'] is not None:  # noqa: E501
            query_params.append(('attribute_gt', local_var_params['attribute.gt']))  # noqa: E501
        if 'attribute.gte' in local_var_params and local_var_params['attribute.gte'] is not None:  # noqa: E501
            query_params.append(('attribute_gte', local_var_params['attribute.gte']))  # noqa: E501
        if 'attribute.contains' in local_var_params and local_var_params['attribute.contains'] is not None:  # noqa: E501
            query_params.append(('attribute_contains', local_var_params['attribute.contains']))  # noqa: E501
        if 'attribute.distance' in local_var_params and local_var_params['attribute.distance'] is not None:  # noqa: E501
            query_params.append(('attribute_distance', local_var_params['attribute.distance']))  # noqa: E501
        if 'attribute.null' in local_var_params and local_var_params['attribute.null'] is not None:  # noqa: E501
            query_params.append(('attribute_null', local_var_params['attribute.null']))  # noqa: E501
        if 'operation' in local_var_params and local_var_params['operation'] is not None:  # noqa: E501
            query_params.append(('operation', local_var_params['operation']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'stop' in local_var_params and local_var_params['stop'] is not None:  # noqa: E501
            query_params.append(('stop', local_var_params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'attribute.bulk.update' in local_var_params:
            body_params = local_var_params['attribute.bulk.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/States/{project}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateStateType(self, id, **kwargs):
        """UpdateStateType

        Update state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateStateType(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state type. (required)
        :param StateTypeUpdate state.type.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateStateType_with_http_info(id, **kwargs)  # noqa: E501

    def UpdateStateType_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Update state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateStateType_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a state type. (required)
        :param StateTypeUpdate state.type.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'state.type.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateStateType" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `UpdateStateType`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'state.type.update' in local_var_params:
            body_params = local_var_params['state.type.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/StateType/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateUser(self, id, **kwargs):
        """UpdateUser

        Update user.

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateUser(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a localization association. (required)
        :param UserUpdate user.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateUser_with_http_info(id, **kwargs)  # noqa: E501

    def UpdateUser_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Update user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateUser_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a localization association. (required)
        :param UserUpdate user.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'user.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateUser" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `UpdateUser`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user.update' in local_var_params:
            body_params = local_var_params['user.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/User/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateVersion(self, id, **kwargs):
        """UpdateVersion

        Update version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateVersion(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a version. (required)
        :param VersionUpdate version.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.MessageResponse`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateVersion_with_http_info(id, **kwargs)  # noqa: E501

    def UpdateVersion_with_http_info(self, id, **kwargs):  # noqa: E501
        """
        Update version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.     # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateVersion_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer id: A unique integer identifying a version. (required)
        :param VersionUpdate version.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.MessageResponse`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'version.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateVersion" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `UpdateVersion`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'version.update' in local_var_params:
            body_params = local_var_params['version.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Version/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def UpdateVideo(self, project, **kwargs):
        """UpdateVideo

        Saves a transcoded video.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. To launch a transcode on raw uploaded video, use the `Transcode` endpoint, which will create an Argo workflow to perform the transcode and save the video using this endpoint; no further REST calls are required. However, if you would like to perform transcodes locally, this endpoint enables that. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateVideo(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param VideoUpdate video.update:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.UpdateVideo_with_http_info(project, **kwargs)  # noqa: E501

    def UpdateVideo_with_http_info(self, project, **kwargs):  # noqa: E501
        """
        Saves a transcoded video.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. To launch a transcode on raw uploaded video, use the `Transcode` endpoint, which will create an Argo workflow to perform the transcode and save the video using this endpoint; no further REST calls are required. However, if you would like to perform transcodes locally, this endpoint enables that.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.UpdateVideo_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param integer project: A unique integer identifying a project. (required)
        :param VideoUpdate video.update:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project',
            'video.update'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method UpdateVideo" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project' is set
        if self.api_client.client_side_validation and ('project' not in local_var_params or  # noqa: E501
                                                        local_var_params['project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project` when calling `UpdateVideo`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in local_var_params:
            path_params['project'] = local_var_params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'video.update' in local_var_params:
            body_params = local_var_params['video.update']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/SaveVideo/{project}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def Whoami(self, **kwargs):
        """Whoami

        Get current user.  Retrieves user making the request. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.Whoami(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: :class:`tator.models.User`
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.Whoami_with_http_info(**kwargs)  # noqa: E501

    def Whoami_with_http_info(self, **kwargs):  # noqa: E501
        """
        Get current user.  Retrieves user making the request.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.Whoami_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(:class:`tator.models.User`, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method Whoami" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/User/GetCurrent', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
