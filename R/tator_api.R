# Tator REST API
#
# Interface to the Tator backend.
#
# The version of the OpenAPI document: v1
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Tator operations
#' @description tator.Tator
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ AlgorithmLaunch } \emph{  }
#' Launch a registered algorithm.  This will create one or more Argo workflows that execute the named algorithm registration. To get a list of available algorithms, use the &#x60;Algorithms&#x60; endpoint. A media list will be submitted for processing using either a query string or  a list of media IDs. If neither are included, the algorithm will be launched on all media in the project.   Media is divided into batches for based on the &#x60;files_per_job&#x60; field of the  &#x60;Algorithm&#x60; object. One batch is submitted to each Argo workflow.  Submitted algorithm jobs may be cancelled via the &#x60;Job&#x60; or &#x60;JobGroup&#x60; endpoints. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } algorithm.launch.spec \link{AlgorithmLaunchSpec}
#' \item \emph{ @returnType } \link{AlgorithmLaunch} \cr
#'
#'
#' \item status code : 201 | Successful launch of algorithm.
#'
#' \item return type : AlgorithmLaunch 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateAnalysis } \emph{  }
#' Create analysis.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } analysis.spec \link{AnalysisSpec}
#' \item \emph{ @returnType } \link{CreateResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of analysis.
#'
#' \item return type : CreateResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateLeafList } \emph{  }
#' Create leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method does a bulk create on a list of &#x60;LeafSpec&#x60; objects. A  maximum of 500 leaves may be created in one request. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } leaf.spec list( \link{LeafSpec} )
#' \item \emph{ @returnType } \link{CreateListResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of leaf.
#'
#' \item return type : CreateListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateLeafType } \emph{  }
#' Create leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } leaf.type.spec \link{LeafTypeSpec}
#' \item \emph{ @returnType } \link{CreateResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of leaf type.
#'
#' \item return type : CreateResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateLocalizationList } \emph{  }
#' Create localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (&#x60;dtype&#x60;) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - &#x60;box&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;width&#x60;, &#x60;height&#x60;. - &#x60;line&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;u&#x60;, &#x60;v&#x60;. - &#x60;dot&#x60; uses &#x60;x&#x60; and &#x60;y&#x60;.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk create on a list of &#x60;LocalizationSpec&#x60; objects. A  maximum of 500 localizations may be created in one request. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } localization.spec list( \link{LocalizationSpec} )
#' \item \emph{ @returnType } \link{CreateListResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of localization(s).
#'
#' \item return type : CreateListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateLocalizationType } \emph{  }
#' Create localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } localization.type.spec \link{LocalizationTypeSpec}
#' \item \emph{ @returnType } \link{CreateResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of localization type.
#'
#' \item return type : CreateResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateMediaType } \emph{  }
#' Create media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.type.spec \link{MediaTypeSpec}
#' \item \emph{ @returnType } \link{CreateResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of media type.
#'
#' \item return type : CreateResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateMembership } \emph{  }
#' Create membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - &#x60;View Only&#x60; can only view a project and not change any data. - &#x60;Can Edit&#x60; can create, modify, and delete annotations. - &#x60;Can Transfer&#x60; can upload and download media. - &#x60;Can Execute&#x60; can launch algorithm workflows. - &#x60;Full Control&#x60; can change project settings, including inviting new members, project name, and    project metadata schema. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } membership.spec \link{MembershipSpec}
#' \item \emph{ @returnType } \link{CreateResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of membership.
#'
#' \item return type : CreateResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateObtainAuthToken } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } credentials \link{Credentials}
#' \item \emph{ @returnType } \link{Token} \cr
#'
#'
#' \item status code : 200 | Login credentials accepted.
#'
#' \item return type : Token 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Login credentials invalid.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateProgressSummaryAPI } \emph{  }
#' Create or update a progress summary.  This endpoint sets a key in redis that indicates how many jobs are in a job group as well as how many are completed. This is used to display summary progress in the progress bar. If not used for a given job group, the job completion is computed from the status of individual jobs in the group. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } progress.summary.spec \link{ProgressSummarySpec}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of progress summary message.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateProject } \emph{  }
#' Create project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   
#'
#' \itemize{
#' \item \emph{ @param } project.spec \link{ProjectSpec}
#' \item \emph{ @returnType } \link{CreateResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of project.
#'
#' \item return type : CreateResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateStateList } \emph{  }
#' Create state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk create on a list of &#x60;StateSpec&#x60; objects. A  maximum of 500 states may be created in one request. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } state.spec list( \link{StateSpec} )
#' \item \emph{ @returnType } \link{CreateListResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of state(s).
#'
#' \item return type : CreateListResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateStateType } \emph{  }
#' Create state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } state.type.spec \link{StateTypeSpec}
#' \item \emph{ @returnType } \link{CreateResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of state type.
#'
#' \item return type : CreateResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateTemporaryFile } \emph{  }
#' Create temporary file.  Temporary files are files stored server side for a defined duration.   The file must first be uploaded via tus, and can subsequently be saved using this endpoint.
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } temporary.file.spec \link{TemporaryFileSpec}
#' \item \emph{ @returnType } \link{CreateResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of temporary file.
#'
#' \item return type : CreateResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateVersion } \emph{  }
#' Create version.  Versions allow for multiple \&quot;layers\&quot; of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the &#x60;modified&#x60; flag to determine whether an annotation should be displayed for a given media while annotating. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } version.spec \link{VersionSpec}
#' \item \emph{ @returnType } \link{CreateResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of version.
#'
#' \item return type : CreateResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteJob } \emph{  }
#' Cancel a background job.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.  This endpoint allows the user to cancel a job using the &#x60;run_uid&#x60; returned by either the &#x60;AlgorithmLaunch&#x60; or &#x60;Transcode&#x60; endpoints. 
#'
#' \itemize{
#' \item \emph{ @param } run.uid character
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful cancellation of job.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteJobGroup } \emph{  }
#' Cancel a group of background jobs.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.  This endpoint allows the user to cancel a group of jobs using the &#x60;group_id&#x60;  returned by either the &#x60;AlgorithmLaunch&#x60; or &#x60;Transcode&#x60; endpoints. 
#'
#' \itemize{
#' \item \emph{ @param } group.id character
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful cancellation of job group.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteLeaf } \emph{  }
#' Delete leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#'
#'
#' \item status code : 200 | Successful deletion of leaf.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteLeafList } \emph{  }
#' Delete leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method performs a bulk delete on all leaves matching a query. It is  recommended to use a GET request first to check what is being deleted. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } ancestor character
#' \item \emph{ @param } type integer
#' \item \emph{ @param } name character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of leaf list.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteLeafType } \emph{  }
#' Delete leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of leaf type.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteLocalization } \emph{  }
#' Delete localization.  Localizations are shape annotations drawn on a video or image. Available shapes (&#x60;dtype&#x60;) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - &#x60;box&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;width&#x60;, &#x60;height&#x60;. - &#x60;line&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;u&#x60;, &#x60;v&#x60;. - &#x60;dot&#x60; uses &#x60;x&#x60; and &#x60;y&#x60;.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of localization.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteLocalizationList } \emph{  }
#' Delete localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (&#x60;dtype&#x60;) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - &#x60;box&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;width&#x60;, &#x60;height&#x60;. - &#x60;line&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;u&#x60;, &#x60;v&#x60;. - &#x60;dot&#x60; uses &#x60;x&#x60; and &#x60;y&#x60;.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all localizations matching a query. It is  recommended to use a GET request first to check what is being deleted. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.query character
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @param } version list( integer )
#' \item \emph{ @param } modified Enum < [0, 1] > 
#' \item \emph{ @param } after integer
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @param } exclude.parents integer
#' \item \emph{ @param } frame integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of localization list.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteLocalizationType } \emph{  }
#' Delete localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   Note that this will also delete any localizations associated with the localization type. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of localization type.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteMedia } \emph{  }
#' Delete media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of media.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteMediaList } \emph{  }
#' Delete media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all media matching a query. It is  recommended to use a GET request first to check what is being deleted. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @param } name character
#' \item \emph{ @param } md5 character
#' \item \emph{ @param } after character
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of media list.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteMediaType } \emph{  }
#' Delete media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   Note that this will also delete any media associated with the media type. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of media type.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteMembership } \emph{  }
#' Delete membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - &#x60;View Only&#x60; can only view a project and not change any data. - &#x60;Can Edit&#x60; can create, modify, and delete annotations. - &#x60;Can Transfer&#x60; can upload and download media. - &#x60;Can Execute&#x60; can launch algorithm workflows. - &#x60;Full Control&#x60; can change project settings, including inviting new members, project name, and    project metadata schema. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of membership.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteProject } \emph{  }
#' Delete project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   Only project owners may delete a project. Note that deleting a project will also delete all media and annotations within a project. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of project.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteState } \emph{  }
#' Delete state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of state.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteStateList } \emph{  }
#' Delete state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all states matching a query. It is  recommended to use a GET request first to check what is being deleted. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.query character
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @param } version list( integer )
#' \item \emph{ @param } modified Enum < [0, 1] > 
#' \item \emph{ @param } after integer
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of state list.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteStateType } \emph{  }
#' Delete state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   Note that this will also delete any states associated with the state type. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of state type.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteTemporaryFile } \emph{  }
#' Delete temporary file.  Temporary files are files stored server side for a defined duration. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of temporary file.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteTemporaryFileList } \emph{  }
#' Delete temporary file list.  Temporary files are files stored server side for a defined duration.   
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } expired integer
#'
#'
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteVersion } \emph{  }
#' Delete version.  Versions allow for multiple \&quot;layers\&quot; of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the &#x60;modified&#x60; flag to determine whether an annotation should be displayed for a given media while annotating.   Note that this will also delete any localizations or states associated with the deleted version. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful deletion of version.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetAlgorithmList } \emph{  }
#' Get algorithms.  Algorithms must be registered to a project as an argo workflow. For  instructions on how to register an algorithm, see the documentation:   &lt;https://github.com/cvisionai/tator/tree/master/examples/algorithms&gt; 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @returnType } list( \link{Algorithm} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of registered algorithms.
#'
#' \item return type : array[Algorithm] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetAnalysisList } \emph{  }
#' Get analysis.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @returnType } list( \link{Analysis} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of analyses.
#'
#' \item return type : array[Analysis] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Failure to find project with given ID.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetClip } \emph{  }
#' Get video clip.  Facility to get a clip from the server. Returns a temporary file object that expires in 24 hours. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } frame.ranges list( character )
#' \item \emph{ @param } quality integer
#' \item \emph{ @returnType } \link{TemporaryFile} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of video clip.
#'
#' \item return type : TemporaryFile 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetFrame } \emph{  }
#' Get frame(s) from a video.  Facility to get a frame(jpg/png) of a given video frame, returns a square tile of frames based on the input parameter. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } frames list( integer )
#' \item \emph{ @param } tile character
#' \item \emph{ @param } roi character
#' \item \emph{ @param } animate integer
#' \item \emph{ @param } quality integer
#'
#'
#' \item status code : 200 | Successful retrieval of frame image.
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetLeaf } \emph{  }
#' Get leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{Leaf} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of leaf.
#'
#' \item return type : Leaf 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetLeafList } \emph{  }
#' Get leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } ancestor character
#' \item \emph{ @param } type integer
#' \item \emph{ @param } name character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @returnType } list( \link{Leaf} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of leaf list.
#'
#' \item return type : array[Leaf] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetLeafType } \emph{  }
#' Get leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{LeafType} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of leaf type.
#'
#' \item return type : LeafType 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetLeafTypeList } \emph{  }
#' Get leaf type list.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @returnType } list( \link{LeafType} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of leaf type list.
#'
#' \item return type : array[LeafType] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetLocalization } \emph{  }
#' Get localization.  Localizations are shape annotations drawn on a video or image. Available shapes (&#x60;dtype&#x60;) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - &#x60;box&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;width&#x60;, &#x60;height&#x60;. - &#x60;line&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;u&#x60;, &#x60;v&#x60;. - &#x60;dot&#x60; uses &#x60;x&#x60; and &#x60;y&#x60;.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{Localization} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of localization.
#'
#' \item return type : Localization 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetLocalizationList } \emph{  }
#' Get localization list.  Localizations are shape annotations drawn on a video or image. Available shapes (&#x60;dtype&#x60;) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - &#x60;box&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;width&#x60;, &#x60;height&#x60;. - &#x60;line&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;u&#x60;, &#x60;v&#x60;. - &#x60;dot&#x60; uses &#x60;x&#x60; and &#x60;y&#x60;.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.query character
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @param } version list( integer )
#' \item \emph{ @param } modified Enum < [0, 1] > 
#' \item \emph{ @param } after integer
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @param } exclude.parents integer
#' \item \emph{ @param } frame integer
#' \item \emph{ @returnType } list( \link{Localization} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of localization list.
#'
#' \item return type : array[Localization] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetLocalizationType } \emph{  }
#' Get localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{LocalizationType} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of localization type.
#'
#' \item return type : LocalizationType 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetLocalizationTypeList } \emph{  }
#' Get localization type list.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @returnType } list( \link{LocalizationType} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of localization type list.
#'
#' \item return type : array[LocalizationType] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetMedia } \emph{  }
#' Get media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{Media} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of media.
#'
#' \item return type : Media 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetMediaList } \emph{  }
#' Get media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @param } name character
#' \item \emph{ @param } md5 character
#' \item \emph{ @param } after character
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @returnType } list( \link{Media} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of media list.
#'
#' \item return type : array[Media] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetMediaNext } \emph{  }
#' Retrieve ID of next media in a media list.  This endpoint accepts the same query parameters as a GET request to the &#x60;Medias&#x60; endpoint, but only returns the next media ID from the media passed as a path parameter. This allows iteration through a media list without serializing the entire list, which may be large. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @param } name character
#' \item \emph{ @param } md5 character
#' \item \emph{ @param } after character
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @returnType } \link{MediaNext} \cr
#'
#'
#' \item status code : 200 | ID of next media in the list corresponding to query.
#'
#' \item return type : MediaNext 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetMediaPrev } \emph{  }
#' Retrieve ID of previous media in a media list.  This endpoint accepts the same query parameters as a GET request to the &#x60;Medias&#x60; endpoint, but only returns the previous media ID from the media passed as a path parameter. This  allows iteration through a media list without serializing the entire list, which may be  large. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @param } name character
#' \item \emph{ @param } md5 character
#' \item \emph{ @param } after character
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @returnType } \link{MediaPrev} \cr
#'
#'
#' \item status code : 200 | ID of previous media in the list corresponding to query.
#'
#' \item return type : MediaPrev 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetMediaSections } \emph{  }
#' Retrieve media counts by section.  This endpoint accepts the same query parameters as a GET request to the &#x60;Medias&#x60; endpoint, but only returns the number of images and videos per sections. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @param } name character
#' \item \emph{ @param } md5 character
#' \item \emph{ @param } after character
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#'
#'
#' \item status code : 200 | Successful retrieval of media count per section.
#'
#' \item return type : map(object) 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetMediaType } \emph{  }
#' Get media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{MediaType} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of media type.
#'
#' \item return type : MediaType 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetMediaTypeList } \emph{  }
#' Get media type list.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @returnType } list( \link{MediaType} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of media type list.
#'
#' \item return type : array[MediaType] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetMembership } \emph{  }
#' Get membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - &#x60;View Only&#x60; can only view a project and not change any data. - &#x60;Can Edit&#x60; can create, modify, and delete annotations. - &#x60;Can Transfer&#x60; can upload and download media. - &#x60;Can Execute&#x60; can launch algorithm workflows. - &#x60;Full Control&#x60; can change project settings, including inviting new members, project name, and    project metadata schema. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{Membership} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of membership.
#'
#' \item return type : Membership 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetMembershipList } \emph{  }
#' Get membership list.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - &#x60;View Only&#x60; can only view a project and not change any data. - &#x60;Can Edit&#x60; can create, modify, and delete annotations. - &#x60;Can Transfer&#x60; can upload and download media. - &#x60;Can Execute&#x60; can launch algorithm workflows. - &#x60;Full Control&#x60; can change project settings, including inviting new members, project name, and    project metadata schema. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @returnType } list( \link{Membership} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of membership list.
#'
#' \item return type : array[Membership] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetProject } \emph{  }
#' Get project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{Project} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of project.
#'
#' \item return type : Project 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetProjectList } \emph{  }
#' Get project list.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   Returns all projects that a user has access to.
#'
#' \itemize{
#' \item \emph{ @returnType } list( \link{Project} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of project list.
#'
#' \item return type : array[Project] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetSectionAnalysis } \emph{  }
#' Retrieve analysis results for a media list.  This endpoint uses objects created with the &#x60;Analysis&#x60; endpoint to perform analysis on filtered media lists. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @returnType } named list( \link{AnyType} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of section analysis.
#'
#' \item return type : map(AnyType) 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetState } \emph{  }
#' Get state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{State} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of state.
#'
#' \item return type : State 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetStateGraphic } \emph{  }
#'  Get frame(s) of a given localization-associated state.  Use the mode argument to control whether it is an animated gif or a tiled jpg. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } mode Enum < [animate, tile] > 
#' \item \emph{ @param } fps numeric
#' \item \emph{ @param } force.scale character
#'
#'
#' \item status code : 200 | Successful retrieval of state graphic.
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetStateList } \emph{  }
#' Get state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.query character
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @param } version list( integer )
#' \item \emph{ @param } modified Enum < [0, 1] > 
#' \item \emph{ @param } after integer
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @returnType } list( \link{State} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of state list.
#'
#' \item return type : array[State] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetStateType } \emph{  }
#' Get state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{StateType} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of state type.
#'
#' \item return type : StateType 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetStateTypeList } \emph{  }
#' Get state type list.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @returnType } list( \link{StateType} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of state type list.
#'
#' \item return type : array[StateType] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetTemporaryFile } \emph{  }
#' Get temporary file.  Temporary files are files stored server side for a defined duration. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{TemporaryFile} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of temporary file.
#'
#' \item return type : TemporaryFile 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetTemporaryFileList } \emph{  }
#' Get temporary file list.  Temporary files are files stored server side for a defined duration.   
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } expired integer
#' \item \emph{ @returnType } list( \link{TemporaryFile} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of temporary file list.
#'
#' \item return type : array[TemporaryFile] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetUser } \emph{  }
#' Get user.
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{User} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of user.
#'
#' \item return type : User 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetVersion } \emph{  }
#' Get version.  Versions allow for multiple \&quot;layers\&quot; of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the &#x60;modified&#x60; flag to determine whether an annotation should be displayed for a given media while annotating.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @returnType } \link{Version} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of version.
#'
#' \item return type : Version 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetVersionList } \emph{  }
#' Get version list.  Versions allow for multiple \&quot;layers\&quot; of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the &#x60;modified&#x60; flag to determine whether an annotation should be displayed for a given media while annotating. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.id integer
#' \item \emph{ @returnType } list( \link{Version} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of version list.
#'
#' \item return type : array[Version] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ LeafSuggestion } \emph{  }
#' Get list of autocomplete suggestions.  This endpoint is compatible with devbridge suggestion format. It performs a glob search on leaf objects in the project.  &lt;https://github.com/kraaden/autocomplete&gt; 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } ancestor character
#' \item \emph{ @param } query character
#' \item \emph{ @param } min.level integer
#' \item \emph{ @returnType } list( \link{LeafSuggestion} ) \cr
#'
#'
#' \item status code : 200 | Successful retrieval of suggestions.
#'
#' \item return type : array[LeafSuggestion] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ Notify } \emph{  }
#' Send a notification to administrators.  Uses the Slack API to send a notification to system administrators. This endpoint can only be used by system administrators and must be configured in a Tator deployment&#39;s settings. 
#'
#' \itemize{
#' \item \emph{ @param } notify.spec \link{NotifySpec}
#'
#'
#' \item status code : 201 | Message sent successfully.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 503 | Service not available.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ Progress } \emph{  }
#' Broadcast progress update.  Progress messages are sent in the web UI via WebSocket, and are displayed as progress bars associated with individual media files and as a summary in the webpage header. All members of a project can see progress bars from uploads and background jobs initiated by other users within the project. This endpoint accepts an array of messages, allowing for progress messages to be batched into a single request. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } progress.spec list( \link{ProgressSpec} )
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful creation of progress message.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ SaveImage } \emph{  }
#' Saves an uploaded image.  Media is uploaded via tus, a separate mechanism from the REST API. Once an image upload is complete, the image must be saved to the database using this endpoint. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } image.spec \link{ImageSpec}
#' \item \emph{ @returnType } \link{CreateResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of image.
#'
#' \item return type : CreateResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ SaveVideo } \emph{  }
#' Saves a transcoded video.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. To launch a transcode on raw uploaded video, use the &#x60;Transcode&#x60; endpoint, which will create an Argo workflow to perform the transcode and save the video using this endpoint; no further REST calls are required. However, if you would like to perform transcodes locally, this endpoint enables that. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } video.spec \link{VideoSpec}
#' \item \emph{ @returnType } \link{CreateResponse} \cr
#'
#'
#' \item status code : 201 | Successful creation of video.
#'
#' \item return type : CreateResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ Transcode } \emph{  }
#' Start a transcode.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. This endpoint launches a transcode on raw uploaded video by creating an Argo workflow. The workflow will download the uploaded raw video, transcode it to the proper format, upload the transcoded video, and save the video using the  &#x60;SaveVideo&#x60; endpoint.  Note that the raw video must be uploaded first via tus, which is a separate mechanism  from the REST API. This endpoint requires a group and run UUID associated with this  upload. If no progress messages were generated during upload, then the group and run  UUIDs can be newly generated.  Transcodes may be cancelled via the &#x60;Job&#x60; or &#x60;JobGroup&#x60; endpoints. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } transcode.spec \link{TranscodeSpec}
#' \item \emph{ @returnType } \link{Transcode} \cr
#'
#'
#' \item status code : 201 | Successful save of the video in the database.
#'
#' \item return type : Transcode 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateLeaf } \emph{  }
#' Update leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } leaf.update \link{LeafUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of leaf.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateLeafList } \emph{  }
#' Update leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method does a bulk update on all leaves matching a query. Only  user-defined attributes may be bulk updated. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } ancestor character
#' \item \emph{ @param } type integer
#' \item \emph{ @param } name character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @param } attribute.bulk.update \link{AttributeBulkUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of leaf list.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateLeafType } \emph{  }
#' Update leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } leaf.type.update \link{LeafTypeUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of leaf type.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateLocalization } \emph{  }
#' Update localization.  Localizations are shape annotations drawn on a video or image. Available shapes (&#x60;dtype&#x60;) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - &#x60;box&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;width&#x60;, &#x60;height&#x60;. - &#x60;line&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;u&#x60;, &#x60;v&#x60;. - &#x60;dot&#x60; uses &#x60;x&#x60; and &#x60;y&#x60;.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } localization.update \link{LocalizationUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of localization.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateLocalizationList } \emph{  }
#' Update localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (&#x60;dtype&#x60;) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - &#x60;box&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;width&#x60;, &#x60;height&#x60;. - &#x60;line&#x60; uses &#x60;x&#x60;, &#x60;y&#x60;, &#x60;u&#x60;, &#x60;v&#x60;. - &#x60;dot&#x60; uses &#x60;x&#x60; and &#x60;y&#x60;.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all localizations matching a query. Only  user-defined attributes may be bulk updated. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.query character
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @param } version list( integer )
#' \item \emph{ @param } modified Enum < [0, 1] > 
#' \item \emph{ @param } after integer
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @param } exclude.parents integer
#' \item \emph{ @param } frame integer
#' \item \emph{ @param } attribute.bulk.update \link{AttributeBulkUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of localization list.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateLocalizationType } \emph{  }
#' Update localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } localization.type.update \link{LocalizationTypeUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of localization type.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateMedia } \emph{  }
#' Update media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } media.update \link{MediaUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of media.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateMediaList } \emph{  }
#' Update media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all media matching a query. Only  user-defined attributes may be bulk updated. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @param } name character
#' \item \emph{ @param } md5 character
#' \item \emph{ @param } after character
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @param } attribute.bulk.update \link{AttributeBulkUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of media list.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateMediaType } \emph{  }
#' Update media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } media.type.update \link{MediaTypeUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of media type.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateMembership } \emph{  }
#' Update membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - &#x60;View Only&#x60; can only view a project and not change any data. - &#x60;Can Edit&#x60; can create, modify, and delete annotations. - &#x60;Can Transfer&#x60; can upload and download media. - &#x60;Can Execute&#x60; can launch algorithm workflows. - &#x60;Full Control&#x60; can change project settings, including inviting new members, project name, and    project metadata schema. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } membership.update \link{MembershipUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of membership.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateProject } \emph{  }
#' Update project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } project.spec \link{ProjectSpec}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of project.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateState } \emph{  }
#' Update state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } state.update \link{StateUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of state.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateStateList } \emph{  }
#' Update state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all states matching a query. Only  user-defined attributes may be bulk updated. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } media.query character
#' \item \emph{ @param } media.id list( integer )
#' \item \emph{ @param } type integer
#' \item \emph{ @param } version list( integer )
#' \item \emph{ @param } modified Enum < [0, 1] > 
#' \item \emph{ @param } after integer
#' \item \emph{ @param } search character
#' \item \emph{ @param } attribute character
#' \item \emph{ @param } attribute.lt character
#' \item \emph{ @param } attribute.lte character
#' \item \emph{ @param } attribute.gt character
#' \item \emph{ @param } attribute.gte character
#' \item \emph{ @param } attribute.contains character
#' \item \emph{ @param } attribute.distance character
#' \item \emph{ @param } attribute.null character
#' \item \emph{ @param } operation Enum < [count] > 
#' \item \emph{ @param } start integer
#' \item \emph{ @param } stop integer
#' \item \emph{ @param } attribute.bulk.update \link{AttributeBulkUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of state list.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateStateType } \emph{  }
#' Update state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } state.type.update \link{StateTypeUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of state type.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateUser } \emph{  }
#' Update user.
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } user.update \link{UserUpdate}
#'
#'
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateVersion } \emph{  }
#' Update version.  Versions allow for multiple \&quot;layers\&quot; of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the &#x60;modified&#x60; flag to determine whether an annotation should be displayed for a given media while annotating.   
#'
#' \itemize{
#' \item \emph{ @param } id integer
#' \item \emph{ @param } version.update \link{VersionUpdate}
#' \item \emph{ @returnType } \link{MessageResponse} \cr
#'
#'
#' \item status code : 200 | Successful update of version.
#'
#' \item return type : MessageResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateVideo } \emph{  }
#' Saves a transcoded video.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. To launch a transcode on raw uploaded video, use the &#x60;Transcode&#x60; endpoint, which will create an Argo workflow to perform the transcode and save the video using this endpoint; no further REST calls are required. However, if you would like to perform transcodes locally, this endpoint enables that. 
#'
#' \itemize{
#' \item \emph{ @param } project integer
#' \item \emph{ @param } video.update \link{VideoUpdate}
#'
#'
#' \item status code : 400 | Bad request.
#'
#' \item return type : BadRequestResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Not found.
#'
#' \item return type : NotFoundResponse 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ Whoami } \emph{  }
#' Get current user.  Retrieves user making the request. 
#'
#' \itemize{
#' \item \emph{ @returnType } \link{User} \cr
#'
#'
#' \item status code : 200 | Successful retrieval of user who sent request.
#'
#' \item return type : User 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  AlgorithmLaunch  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.algorithm.launch.spec <- {"algorithm_name":"My Algorithm","media_ids":[1,5,10]} # AlgorithmLaunchSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$AlgorithmLaunch(var.project, algorithm.launch.spec=var.algorithm.launch.spec)
#'
#'
#' ####################  CreateAnalysis  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.analysis.spec <- {"data_query":"_meta:1","name":"Boxes"} # AnalysisSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateAnalysis(var.project, analysis.spec=var.analysis.spec)
#'
#'
#' ####################  CreateLeafList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.leaf.spec <- [LeafSpec$new()] # array[LeafSpec] | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateLeafList(var.project, leaf.spec=var.leaf.spec)
#'
#'
#' ####################  CreateLeafType  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.leaf.type.spec <- {"attribute_types":[{"default":false,"dtype":"bool","name":"My Boolean"},{"default":0,"dtype":"int","maximum":1,"minimum":-1,"name":"My Integer"},{"default":0.0,"dtype":"float","maximum":1.0,"minimum":-1.0,"name":"My Float"},{"choices":["a","b","c"],"default":"a","dtype":"enum","labels":["a","b","c"],"name":"My Enumeration"},{"autocomplete":{"serviceUrl":"https://www.example.com/suggestion"},"default":"---","dtype":"string","name":"My String"},{"dtype":"datetime","name":"My Datetime","use_current":true},{"default":[-179.0,90.0],"dtype":"geopos","name":"My Geoposition"}],"name":"My leaf type"} # LeafTypeSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateLeafType(var.project, leaf.type.spec=var.leaf.type.spec)
#'
#'
#' ####################  CreateLocalizationList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.localization.spec <- [{"My First Attribute":"value1","My Second Attribute":"value2","frame":1000,"height":0.4,"media_id":1,"type":1,"width":0.3,"x":0.1,"y":0.2}] # array[LocalizationSpec] | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateLocalizationList(var.project, localization.spec=var.localization.spec)
#'
#'
#' ####################  CreateLocalizationType  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.localization.type.spec <- {"attribute_types":[{"default":false,"dtype":"bool","name":"My Boolean"},{"default":0,"dtype":"int","maximum":1,"minimum":-1,"name":"My Integer"},{"default":0.0,"dtype":"float","maximum":1.0,"minimum":-1.0,"name":"My Float"},{"choices":["a","b","c"],"default":"a","dtype":"enum","labels":["a","b","c"],"name":"My Enumeration"},{"autocomplete":{"serviceUrl":"https://www.example.com/suggestion"},"default":"---","dtype":"string","name":"My String"},{"dtype":"datetime","name":"My Datetime","use_current":true},{"default":[-179.0,90.0],"dtype":"geopos","name":"My Geoposition"}],"dtype":"box","media_types":[1],"name":"My localization type"} # LocalizationTypeSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateLocalizationType(var.project, localization.type.spec=var.localization.type.spec)
#'
#'
#' ####################  CreateMediaType  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.type.spec <- {"attribute_types":[{"default":false,"dtype":"bool","name":"My Boolean"},{"default":0,"dtype":"int","maximum":1,"minimum":-1,"name":"My Integer"},{"default":0.0,"dtype":"float","maximum":1.0,"minimum":-1.0,"name":"My Float"},{"choices":["a","b","c"],"default":"a","dtype":"enum","labels":["a","b","c"],"name":"My Enumeration"},{"autocomplete":{"serviceUrl":"https://www.example.com/suggestion"},"default":"---","dtype":"string","name":"My String"},{"dtype":"datetime","name":"My Datetime","use_current":true},{"default":[-179.0,90.0],"dtype":"geopos","name":"My Geoposition"}],"dtype":"video","name":"My media type"} # MediaTypeSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateMediaType(var.project, media.type.spec=var.media.type.spec)
#'
#'
#' ####################  CreateMembership  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.membership.spec <- {"permission":"Full Control","user":1} # MembershipSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateMembership(var.project, membership.spec=var.membership.spec)
#'
#'
#' ####################  CreateObtainAuthToken  ####################
#'
#' library(tator)
#' var.credentials <- Credentials$new() # Credentials | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateObtainAuthToken(credentials=var.credentials)
#'
#'
#' ####################  CreateProgressSummaryAPI  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.progress.summary.spec <- ProgressSummarySpec$new() # ProgressSummarySpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateProgressSummaryAPI(var.project, progress.summary.spec=var.progress.summary.spec)
#'
#'
#' ####################  CreateProject  ####################
#'
#' library(tator)
#' var.project.spec <- {"name":"My Project","summary":"First project"} # ProjectSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateProject(project.spec=var.project.spec)
#'
#'
#' ####################  CreateStateList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.state.spec <- [{"My First Attribute":"value1","My Second Attribute":"value2","frame":1000,"media_ids":[1],"type":1}] # array[StateSpec] | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateStateList(var.project, state.spec=var.state.spec)
#'
#'
#' ####################  CreateStateType  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.state.type.spec <- {"association":"Frame","attribute_types":[{"default":false,"dtype":"bool","name":"My Boolean"},{"default":0,"dtype":"int","maximum":1,"minimum":-1,"name":"My Integer"},{"default":0.0,"dtype":"float","maximum":1.0,"minimum":-1.0,"name":"My Float"},{"choices":["a","b","c"],"default":"a","dtype":"enum","labels":["a","b","c"],"name":"My Enumeration"},{"autocomplete":{"serviceUrl":"https://www.example.com/suggestion"},"default":"---","dtype":"string","name":"My String"},{"dtype":"datetime","name":"My Datetime","use_current":true},{"default":[-179.0,90.0],"dtype":"geopos","name":"My Geoposition"}],"media_types":[1],"name":"My state type"} # StateTypeSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateStateType(var.project, state.type.spec=var.state.type.spec)
#'
#'
#' ####################  CreateTemporaryFile  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.temporary.file.spec <- TemporaryFileSpec$new() # TemporaryFileSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateTemporaryFile(var.project, temporary.file.spec=var.temporary.file.spec)
#'
#'
#' ####################  CreateVersion  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.version.spec <- {"bases":[1],"description":"New description","name":"My new version","show_empty":true} # VersionSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CreateVersion(var.project, version.spec=var.version.spec)
#'
#'
#' ####################  DeleteJob  ####################
#'
#' library(tator)
#' var.run.uid <- 'run.uid_example' # character | A uuid1 string identifying to single Job.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteJob(var.run.uid)
#'
#'
#' ####################  DeleteJobGroup  ####################
#'
#' library(tator)
#' var.group.id <- 'group.id_example' # character | A uuid1 string identifying a group of jobs.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteJobGroup(var.group.id)
#'
#'
#' ####################  DeleteLeaf  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a leaf.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteLeaf(var.id)
#'
#'
#' ####################  DeleteLeafList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.ancestor <- 'ancestor_example' # character | Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia).
#' var.type <- 56 # integer | Unique integer identifying a leaf type.
#' var.name <- 'name_example' # character | Name of the leaf element.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteLeafList(var.project, ancestor=var.ancestor, type=var.type, name=var.name, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop)
#'
#'
#' ####################  DeleteLeafType  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying an leaf type.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteLeafType(var.id)
#'
#'
#' ####################  DeleteLocalization  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a localization.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteLocalization(var.id)
#'
#'
#' ####################  DeleteLocalizationList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.query <- 'media.query_example' # character | Query string used to filter media IDs. If supplied, media_id will be ignored.
#' var.media.id <- [56] # array[integer] | Comma-separated list of media IDs.
#' var.type <- 56 # integer | Unique integer identifying a annotation type.
#' var.version <- [56] # array[integer] | List of integers representing versions to fetch
#' var.modified <- 1 # integer | Whether to return original or modified annotations, 0 or 1.
#' var.after <- 56 # integer | If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#' var.exclude.parents <- 0 # integer | If a clone is present, do not send parent. (0 or 1)
#' var.frame <- 56 # integer | Frame number of this localization if it is in a video.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteLocalizationList(var.project, media.query=var.media.query, media.id=var.media.id, type=var.type, version=var.version, modified=var.modified, after=var.after, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop, exclude.parents=var.exclude.parents, frame=var.frame)
#'
#'
#' ####################  DeleteLocalizationType  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying an localization type.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteLocalizationType(var.id)
#'
#'
#' ####################  DeleteMedia  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a media.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteMedia(var.id)
#'
#'
#' ####################  DeleteMediaList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.id <- [56] # array[integer] | List of integers identifying media.
#' var.type <- 56 # integer | Unique integer identifying media type.
#' var.name <- 'name_example' # character | Name of the media to filter on.
#' var.md5 <- 'md5_example' # character | MD5 sum of the media file.
#' var.after <- 'after_example' # character | If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteMediaList(var.project, media.id=var.media.id, type=var.type, name=var.name, md5=var.md5, after=var.after, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop)
#'
#'
#' ####################  DeleteMediaType  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying an media type.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteMediaType(var.id)
#'
#'
#' ####################  DeleteMembership  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a membership.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteMembership(var.id)
#'
#'
#' ####################  DeleteProject  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a project.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteProject(var.id)
#'
#'
#' ####################  DeleteState  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a state.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteState(var.id)
#'
#'
#' ####################  DeleteStateList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.query <- 'media.query_example' # character | Query string used to filter media IDs. If supplied, media_id will be ignored.
#' var.media.id <- [56] # array[integer] | Comma-separated list of media IDs.
#' var.type <- 56 # integer | Unique integer identifying a annotation type.
#' var.version <- [56] # array[integer] | List of integers representing versions to fetch
#' var.modified <- 1 # integer | Whether to return original or modified annotations, 0 or 1.
#' var.after <- 56 # integer | If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteStateList(var.project, media.query=var.media.query, media.id=var.media.id, type=var.type, version=var.version, modified=var.modified, after=var.after, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop)
#'
#'
#' ####################  DeleteStateType  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a state type.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteStateType(var.id)
#'
#'
#' ####################  DeleteTemporaryFile  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a temporary file.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteTemporaryFile(var.id)
#'
#'
#' ####################  DeleteTemporaryFileList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.expired <- 0 # integer | If greater than 0 will return only expired files
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteTemporaryFileList(var.project, expired=var.expired)
#'
#'
#' ####################  DeleteVersion  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a version.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DeleteVersion(var.id)
#'
#'
#' ####################  GetAlgorithmList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetAlgorithmList(var.project)
#'
#'
#' ####################  GetAnalysisList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetAnalysisList(var.project)
#'
#'
#' ####################  GetClip  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a media object.
#' var.frame.ranges <- ['[\"0:30\",\"50:90\"]'] # array[character] | Comma-seperated list of frame ranges to capture.
#' var.quality <- 56 # integer | Source resolution to use (default to highest quality)
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetClip(var.id, var.frame.ranges, quality=var.quality)
#'
#'
#' ####################  GetFrame  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a media object.
#' var.frames <- c(0) # array[integer] | Comma-seperated list of frames to capture.
#' var.tile <- 'tile_example' # character | wxh, if not supplied is made as squarish as possible.
#' var.roi <- 'roi_example' # character | w:h:x:y, optionally crop each frame to a given roi in relative coordinates.
#' var.animate <- 56 # integer | If not tiling, animate each frame at a given fps in a gif.
#' var.quality <- 56 # integer | Source resolution to use (default to highest quality)
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetFrame(var.id, frames=var.frames, tile=var.tile, roi=var.roi, animate=var.animate, quality=var.quality)
#'
#'
#' ####################  GetLeaf  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a leaf.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetLeaf(var.id)
#'
#'
#' ####################  GetLeafList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.ancestor <- 'ancestor_example' # character | Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia).
#' var.type <- 56 # integer | Unique integer identifying a leaf type.
#' var.name <- 'name_example' # character | Name of the leaf element.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetLeafList(var.project, ancestor=var.ancestor, type=var.type, name=var.name, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop)
#'
#'
#' ####################  GetLeafType  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying an leaf type.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetLeafType(var.id)
#'
#'
#' ####################  GetLeafTypeList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetLeafTypeList(var.project)
#'
#'
#' ####################  GetLocalization  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a localization.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetLocalization(var.id)
#'
#'
#' ####################  GetLocalizationList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.query <- 'media.query_example' # character | Query string used to filter media IDs. If supplied, media_id will be ignored.
#' var.media.id <- [56] # array[integer] | Comma-separated list of media IDs.
#' var.type <- 56 # integer | Unique integer identifying a annotation type.
#' var.version <- [56] # array[integer] | List of integers representing versions to fetch
#' var.modified <- 1 # integer | Whether to return original or modified annotations, 0 or 1.
#' var.after <- 56 # integer | If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#' var.exclude.parents <- 0 # integer | If a clone is present, do not send parent. (0 or 1)
#' var.frame <- 56 # integer | Frame number of this localization if it is in a video.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetLocalizationList(var.project, media.query=var.media.query, media.id=var.media.id, type=var.type, version=var.version, modified=var.modified, after=var.after, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop, exclude.parents=var.exclude.parents, frame=var.frame)
#'
#'
#' ####################  GetLocalizationType  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying an localization type.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetLocalizationType(var.id)
#'
#'
#' ####################  GetLocalizationTypeList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.id <- [56] # array[integer] | List of unique integers identifying a media.
#' var.type <- 56 # integer | Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetLocalizationTypeList(var.project, media.id=var.media.id, type=var.type)
#'
#'
#' ####################  GetMedia  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a media.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetMedia(var.id)
#'
#'
#' ####################  GetMediaList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.id <- [56] # array[integer] | List of integers identifying media.
#' var.type <- 56 # integer | Unique integer identifying media type.
#' var.name <- 'name_example' # character | Name of the media to filter on.
#' var.md5 <- 'md5_example' # character | MD5 sum of the media file.
#' var.after <- 'after_example' # character | If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetMediaList(var.project, media.id=var.media.id, type=var.type, name=var.name, md5=var.md5, after=var.after, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop)
#'
#'
#' ####################  GetMediaNext  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a media object.
#' var.media.id <- [56] # array[integer] | List of integers identifying media.
#' var.type <- 56 # integer | Unique integer identifying media type.
#' var.name <- 'name_example' # character | Name of the media to filter on.
#' var.md5 <- 'md5_example' # character | MD5 sum of the media file.
#' var.after <- 'after_example' # character | If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetMediaNext(var.id, media.id=var.media.id, type=var.type, name=var.name, md5=var.md5, after=var.after, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop)
#'
#'
#' ####################  GetMediaPrev  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a media object.
#' var.media.id <- [56] # array[integer] | List of integers identifying media.
#' var.type <- 56 # integer | Unique integer identifying media type.
#' var.name <- 'name_example' # character | Name of the media to filter on.
#' var.md5 <- 'md5_example' # character | MD5 sum of the media file.
#' var.after <- 'after_example' # character | If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetMediaPrev(var.id, media.id=var.media.id, type=var.type, name=var.name, md5=var.md5, after=var.after, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop)
#'
#'
#' ####################  GetMediaSections  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.id <- [56] # array[integer] | List of integers identifying media.
#' var.type <- 56 # integer | Unique integer identifying media type.
#' var.name <- 'name_example' # character | Name of the media to filter on.
#' var.md5 <- 'md5_example' # character | MD5 sum of the media file.
#' var.after <- 'after_example' # character | If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetMediaSections(var.project, media.id=var.media.id, type=var.type, name=var.name, md5=var.md5, after=var.after, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop)
#'
#'
#' ####################  GetMediaType  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying an media type.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetMediaType(var.id)
#'
#'
#' ####################  GetMediaTypeList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetMediaTypeList(var.project)
#'
#'
#' ####################  GetMembership  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a membership.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetMembership(var.id)
#'
#'
#' ####################  GetMembershipList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetMembershipList(var.project)
#'
#'
#' ####################  GetProject  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a project.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetProject(var.id)
#'
#'
#' ####################  GetProjectList  ####################
#'
#' library(tator)
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetProjectList()
#'
#'
#' ####################  GetSectionAnalysis  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.id <- [56] # array[integer] | Unique integer identifying a media. Use this to do analyis on a single file instead of sections.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetSectionAnalysis(var.project, media.id=var.media.id, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop)
#'
#'
#' ####################  GetState  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a state.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetState(var.id)
#'
#'
#' ####################  GetStateGraphic  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a state.
#' var.mode <- 'animate' # character | Whether to animate or tile.
#' var.fps <- 2 # numeric | Frame rate if `mode` is `animate`.
#' var.force.scale <- '240x240' # character | wxh to force each tile prior to stich
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetStateGraphic(var.id, mode=var.mode, fps=var.fps, force.scale=var.force.scale)
#'
#'
#' ####################  GetStateList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.query <- 'media.query_example' # character | Query string used to filter media IDs. If supplied, media_id will be ignored.
#' var.media.id <- [56] # array[integer] | Comma-separated list of media IDs.
#' var.type <- 56 # integer | Unique integer identifying a annotation type.
#' var.version <- [56] # array[integer] | List of integers representing versions to fetch
#' var.modified <- 1 # integer | Whether to return original or modified annotations, 0 or 1.
#' var.after <- 56 # integer | If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetStateList(var.project, media.query=var.media.query, media.id=var.media.id, type=var.type, version=var.version, modified=var.modified, after=var.after, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop)
#'
#'
#' ####################  GetStateType  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a state type.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetStateType(var.id)
#'
#'
#' ####################  GetStateTypeList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.id <- [56] # array[integer] | List of unique integers identifying a media.
#' var.type <- 56 # integer | Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetStateTypeList(var.project, media.id=var.media.id, type=var.type)
#'
#'
#' ####################  GetTemporaryFile  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a temporary file.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetTemporaryFile(var.id)
#'
#'
#' ####################  GetTemporaryFileList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.expired <- 0 # integer | If greater than 0 will return only expired files
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetTemporaryFileList(var.project, expired=var.expired)
#'
#'
#' ####################  GetUser  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a localization association.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetUser(var.id)
#'
#'
#' ####################  GetVersion  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a version.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetVersion(var.id)
#'
#'
#' ####################  GetVersionList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.id <- 56 # integer | Unique integer identifying a media.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GetVersionList(var.project, media.id=var.media.id)
#'
#'
#' ####################  LeafSuggestion  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.ancestor <- 'ancestor_example' # character | Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia).
#' var.query <- 'query_example' # character | String to search for matching names.
#' var.min.level <- 56 # integer | Integer specifying level of results that may be returned. For example, 2 refers to grandchildren of the level specified by the `ancestor` parameter.
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$LeafSuggestion(var.project, var.ancestor, var.query, min.level=var.min.level)
#'
#'
#' ####################  Notify  ####################
#'
#' library(tator)
#' var.notify.spec <- NotifySpec$new() # NotifySpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$Notify(notify.spec=var.notify.spec)
#'
#'
#' ####################  Progress  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.progress.spec <- [{"gid":"b722e83e-8272-11ea-8e10-000c294f07cf","job_type":"algorithm","media_ids":"1,2","message":"Job started!","name":"name_of_file.mp4","progress":70,"sections":"Section 1,Section 2","state":"started","uid":"b43d7e54-8272-11ea-8e10-000c294f07cf"}] # array[ProgressSpec] | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$Progress(var.project, progress.spec=var.progress.spec)
#'
#'
#' ####################  SaveImage  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.image.spec <- ImageSpec$new() # ImageSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$SaveImage(var.project, image.spec=var.image.spec)
#'
#'
#' ####################  SaveVideo  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.video.spec <- VideoSpec$new() # VideoSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$SaveVideo(var.project, video.spec=var.video.spec)
#'
#'
#' ####################  Transcode  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.transcode.spec <- TranscodeSpec$new() # TranscodeSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$Transcode(var.project, transcode.spec=var.transcode.spec)
#'
#'
#' ####################  UpdateLeaf  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a leaf.
#' var.leaf.update <- LeafUpdate$new() # LeafUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateLeaf(var.id, leaf.update=var.leaf.update)
#'
#'
#' ####################  UpdateLeafList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.ancestor <- 'ancestor_example' # character | Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia).
#' var.type <- 56 # integer | Unique integer identifying a leaf type.
#' var.name <- 'name_example' # character | Name of the leaf element.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#' var.attribute.bulk.update <- AttributeBulkUpdate$new() # AttributeBulkUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateLeafList(var.project, ancestor=var.ancestor, type=var.type, name=var.name, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop, attribute.bulk.update=var.attribute.bulk.update)
#'
#'
#' ####################  UpdateLeafType  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying an leaf type.
#' var.leaf.type.update <- {"description":"New description","name":"New name"} # LeafTypeUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateLeafType(var.id, leaf.type.update=var.leaf.type.update)
#'
#'
#' ####################  UpdateLocalization  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a localization.
#' var.localization.update <- {"height":0.25,"width":0.25,"x":0.25,"y":0.25} # LocalizationUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateLocalization(var.id, localization.update=var.localization.update)
#'
#'
#' ####################  UpdateLocalizationList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.query <- 'media.query_example' # character | Query string used to filter media IDs. If supplied, media_id will be ignored.
#' var.media.id <- [56] # array[integer] | Comma-separated list of media IDs.
#' var.type <- 56 # integer | Unique integer identifying a annotation type.
#' var.version <- [56] # array[integer] | List of integers representing versions to fetch
#' var.modified <- 1 # integer | Whether to return original or modified annotations, 0 or 1.
#' var.after <- 56 # integer | If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#' var.exclude.parents <- 0 # integer | If a clone is present, do not send parent. (0 or 1)
#' var.frame <- 56 # integer | Frame number of this localization if it is in a video.
#' var.attribute.bulk.update <- {"attributes":{"Species":"Tuna"}} # AttributeBulkUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateLocalizationList(var.project, media.query=var.media.query, media.id=var.media.id, type=var.type, version=var.version, modified=var.modified, after=var.after, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop, exclude.parents=var.exclude.parents, frame=var.frame, attribute.bulk.update=var.attribute.bulk.update)
#'
#'
#' ####################  UpdateLocalizationType  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying an localization type.
#' var.localization.type.update <- {"description":"New description","name":"New name"} # LocalizationTypeUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateLocalizationType(var.id, localization.type.update=var.localization.type.update)
#'
#'
#' ####################  UpdateMedia  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a media.
#' var.media.update <- MediaUpdate$new() # MediaUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateMedia(var.id, media.update=var.media.update)
#'
#'
#' ####################  UpdateMediaList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.id <- [56] # array[integer] | List of integers identifying media.
#' var.type <- 56 # integer | Unique integer identifying media type.
#' var.name <- 'name_example' # character | Name of the media to filter on.
#' var.md5 <- 'md5_example' # character | MD5 sum of the media file.
#' var.after <- 'after_example' # character | If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#' var.attribute.bulk.update <- {"attributes":{"Species":"Tuna"}} # AttributeBulkUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateMediaList(var.project, media.id=var.media.id, type=var.type, name=var.name, md5=var.md5, after=var.after, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop, attribute.bulk.update=var.attribute.bulk.update)
#'
#'
#' ####################  UpdateMediaType  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying an media type.
#' var.media.type.update <- {"description":"New description","name":"New name"} # MediaTypeUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateMediaType(var.id, media.type.update=var.media.type.update)
#'
#'
#' ####################  UpdateMembership  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a membership.
#' var.membership.update <- {"permission":"View Only"} # MembershipUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateMembership(var.id, membership.update=var.membership.update)
#'
#'
#' ####################  UpdateProject  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a project.
#' var.project.spec <- {"name":"New name","summary":"New summary"} # ProjectSpec | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateProject(var.id, project.spec=var.project.spec)
#'
#'
#' ####################  UpdateState  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a state.
#' var.state.update <- {"frame":1001} # StateUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateState(var.id, state.update=var.state.update)
#'
#'
#' ####################  UpdateStateList  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.media.query <- 'media.query_example' # character | Query string used to filter media IDs. If supplied, media_id will be ignored.
#' var.media.id <- [56] # array[integer] | Comma-separated list of media IDs.
#' var.type <- 56 # integer | Unique integer identifying a annotation type.
#' var.version <- [56] # array[integer] | List of integers representing versions to fetch
#' var.modified <- 1 # integer | Whether to return original or modified annotations, 0 or 1.
#' var.after <- 56 # integer | If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
#' var.search <- '\"My search string\"' # character | Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
#' var.attribute <- 'attribute_example' # character | Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lt <- 'attribute.lt_example' # character | Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.lte <- 'attribute.lte_example' # character | Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gt <- 'attribute.gt_example' # character | Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.gte <- 'attribute.gte_example' # character | Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.contains <- 'attribute.contains_example' # character | Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
#' var.attribute.distance <- 'attribute.distance_example' # character | Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
#' var.attribute.null <- 'attribute.null_example' # character | Attribute null filter. Returns elements for which a given attribute is not defined.
#' var.operation <- 'operation_example' # character | Set to \"count\" to return a count of objects instead of the objects.
#' var.start <- 56 # integer | Pagination start index. Index of the first item in a larger list to return.
#' var.stop <- 56 # integer | Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
#' var.attribute.bulk.update <- {"attributes":{"Species":"Tuna"}} # AttributeBulkUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateStateList(var.project, media.query=var.media.query, media.id=var.media.id, type=var.type, version=var.version, modified=var.modified, after=var.after, search=var.search, attribute=var.attribute, attribute.lt=var.attribute.lt, attribute.lte=var.attribute.lte, attribute.gt=var.attribute.gt, attribute.gte=var.attribute.gte, attribute.contains=var.attribute.contains, attribute.distance=var.attribute.distance, attribute.null=var.attribute.null, operation=var.operation, start=var.start, stop=var.stop, attribute.bulk.update=var.attribute.bulk.update)
#'
#'
#' ####################  UpdateStateType  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a state type.
#' var.state.type.update <- {"description":"New description","name":"New name"} # StateTypeUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateStateType(var.id, state.type.update=var.state.type.update)
#'
#'
#' ####################  UpdateUser  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a localization association.
#' var.user.update <- UserUpdate$new() # UserUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateUser(var.id, user.update=var.user.update)
#'
#'
#' ####################  UpdateVersion  ####################
#'
#' library(tator)
#' var.id <- 56 # integer | A unique integer identifying a version.
#' var.version.update <- {"bases":[1],"description":"New description","name":"New name","show_empty":true} # VersionUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateVersion(var.id, version.update=var.version.update)
#'
#'
#' ####################  UpdateVideo  ####################
#'
#' library(tator)
#' var.project <- 56 # integer | A unique integer identifying a project.
#' var.video.update <- VideoUpdate$new() # VideoUpdate | 
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UpdateVideo(var.project, video.update=var.video.update)
#'
#'
#' ####################  Whoami  ####################
#'
#' library(tator)
#'
#' api.instance <- TatorApi$new()
#'
#' #Configure API key authorization: TokenAuth
#' api.instance$apiClient$apiKeys['Authorization'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$Whoami()
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom caTools base64encode
#' @export
TatorApi <- R6::R6Class(
  'TatorApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    AlgorithmLaunch = function(project, algorithm.launch.spec=NULL, ...){
      apiResponse <- self$AlgorithmLaunchWithHttpInfo(project, algorithm.launch.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    AlgorithmLaunchWithHttpInfo = function(project, algorithm.launch.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`algorithm.launch.spec`)) {
        body <- `algorithm.launch.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/AlgorithmLaunch/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "AlgorithmLaunch", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateAnalysis = function(project, analysis.spec=NULL, ...){
      apiResponse <- self$CreateAnalysisWithHttpInfo(project, analysis.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateAnalysisWithHttpInfo = function(project, analysis.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`analysis.spec`)) {
        body <- `analysis.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Analyses/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateLeafList = function(project, leaf.spec=NULL, ...){
      apiResponse <- self$CreateLeafListWithHttpInfo(project, leaf.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateLeafListWithHttpInfo = function(project, leaf.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`leaf.spec`)) {
        body.items = paste(unlist(lapply(leaf.spec, function(param){param$toJSONString()})), collapse = ",")
        body <- paste0('[', body.items, ']')
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Leaves/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateListResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateLeafType = function(project, leaf.type.spec=NULL, ...){
      apiResponse <- self$CreateLeafTypeWithHttpInfo(project, leaf.type.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateLeafTypeWithHttpInfo = function(project, leaf.type.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`leaf.type.spec`)) {
        body <- `leaf.type.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/LeafTypes/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateLocalizationList = function(project, localization.spec=NULL, ...){
      apiResponse <- self$CreateLocalizationListWithHttpInfo(project, localization.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateLocalizationListWithHttpInfo = function(project, localization.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`localization.spec`)) {
        body.items = paste(unlist(lapply(localization.spec, function(param){param$toJSONString()})), collapse = ",")
        body <- paste0('[', body.items, ']')
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Localizations/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateListResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateLocalizationType = function(project, localization.type.spec=NULL, ...){
      apiResponse <- self$CreateLocalizationTypeWithHttpInfo(project, localization.type.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateLocalizationTypeWithHttpInfo = function(project, localization.type.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`localization.type.spec`)) {
        body <- `localization.type.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/LocalizationTypes/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateMediaType = function(project, media.type.spec=NULL, ...){
      apiResponse <- self$CreateMediaTypeWithHttpInfo(project, media.type.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateMediaTypeWithHttpInfo = function(project, media.type.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`media.type.spec`)) {
        body <- `media.type.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/MediaTypes/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateMembership = function(project, membership.spec=NULL, ...){
      apiResponse <- self$CreateMembershipWithHttpInfo(project, membership.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateMembershipWithHttpInfo = function(project, membership.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`membership.spec`)) {
        body <- `membership.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Memberships/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateObtainAuthToken = function(credentials=NULL, ...){
      apiResponse <- self$CreateObtainAuthTokenWithHttpInfo(credentials, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateObtainAuthTokenWithHttpInfo = function(credentials=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`credentials`)) {
        body <- `credentials`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Token"
      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Token", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateProgressSummaryAPI = function(project, progress.summary.spec=NULL, ...){
      apiResponse <- self$CreateProgressSummaryAPIWithHttpInfo(project, progress.summary.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateProgressSummaryAPIWithHttpInfo = function(project, progress.summary.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`progress.summary.spec`)) {
        body <- `progress.summary.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/ProgressSummary/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateProject = function(project.spec=NULL, ...){
      apiResponse <- self$CreateProjectWithHttpInfo(project.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateProjectWithHttpInfo = function(project.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`project.spec`)) {
        body <- `project.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Projects"
      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateStateList = function(project, state.spec=NULL, ...){
      apiResponse <- self$CreateStateListWithHttpInfo(project, state.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateStateListWithHttpInfo = function(project, state.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`state.spec`)) {
        body.items = paste(unlist(lapply(state.spec, function(param){param$toJSONString()})), collapse = ",")
        body <- paste0('[', body.items, ']')
      } else {
        body <- NULL
      }

      urlPath <- "/rest/States/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateListResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateStateType = function(project, state.type.spec=NULL, ...){
      apiResponse <- self$CreateStateTypeWithHttpInfo(project, state.type.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateStateTypeWithHttpInfo = function(project, state.type.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`state.type.spec`)) {
        body <- `state.type.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/StateTypes/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateTemporaryFile = function(project, temporary.file.spec=NULL, ...){
      apiResponse <- self$CreateTemporaryFileWithHttpInfo(project, temporary.file.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateTemporaryFileWithHttpInfo = function(project, temporary.file.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`temporary.file.spec`)) {
        body <- `temporary.file.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/TemporaryFiles/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateVersion = function(project, version.spec=NULL, ...){
      apiResponse <- self$CreateVersionWithHttpInfo(project, version.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateVersionWithHttpInfo = function(project, version.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`version.spec`)) {
        body <- `version.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Versions/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteJob = function(run.uid, ...){
      apiResponse <- self$DeleteJobWithHttpInfo(run.uid, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteJobWithHttpInfo = function(run.uid, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`run.uid`)) {
        stop("Missing required parameter `run.uid`.")
      }

      urlPath <- "/rest/Job/{run_uid}"
      if (!missing(`run.uid`)) {
        urlPath <- gsub(paste0("\\{", "run_uid", "\\}"), URLencode(as.character(`run.uid`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteJobGroup = function(group.id, ...){
      apiResponse <- self$DeleteJobGroupWithHttpInfo(group.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteJobGroupWithHttpInfo = function(group.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`group.id`)) {
        stop("Missing required parameter `group.id`.")
      }

      urlPath <- "/rest/JobGroup/{group_id}"
      if (!missing(`group.id`)) {
        urlPath <- gsub(paste0("\\{", "group_id", "\\}"), URLencode(as.character(`group.id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteLeaf = function(id, ...){
      apiResponse <- self$DeleteLeafWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteLeafWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/Leaf/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteLeafList = function(project, ancestor=NULL, type=NULL, name=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      apiResponse <- self$DeleteLeafListWithHttpInfo(project, ancestor, type, name, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteLeafListWithHttpInfo = function(project, ancestor=NULL, type=NULL, name=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['ancestor'] <- ancestor

      queryParams['type'] <- type

      queryParams['name'] <- name

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      urlPath <- "/rest/Leaves/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteLeafType = function(id, ...){
      apiResponse <- self$DeleteLeafTypeWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteLeafTypeWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/LeafType/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteLocalization = function(id, ...){
      apiResponse <- self$DeleteLocalizationWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteLocalizationWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/Localization/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteLocalizationList = function(project, media.query=NULL, media.id=NULL, type=NULL, version=NULL, modified=1, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, exclude.parents=0, frame=NULL, ...){
      apiResponse <- self$DeleteLocalizationListWithHttpInfo(project, media.query, media.id, type, version, modified, after, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, exclude.parents, frame, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteLocalizationListWithHttpInfo = function(project, media.query=NULL, media.id=NULL, type=NULL, version=NULL, modified=1, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, exclude.parents=0, frame=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_query'] <- media.query

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      queryParams['version'] <- version

      queryParams['modified'] <- modified

      queryParams['after'] <- after

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      queryParams['excludeParents'] <- exclude.parents

      queryParams['frame'] <- frame

      urlPath <- "/rest/Localizations/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteLocalizationType = function(id, ...){
      apiResponse <- self$DeleteLocalizationTypeWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteLocalizationTypeWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/LocalizationType/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteMedia = function(id, ...){
      apiResponse <- self$DeleteMediaWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteMediaWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/Media/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteMediaList = function(project, media.id=NULL, type=NULL, name=NULL, md5=NULL, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      apiResponse <- self$DeleteMediaListWithHttpInfo(project, media.id, type, name, md5, after, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteMediaListWithHttpInfo = function(project, media.id=NULL, type=NULL, name=NULL, md5=NULL, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      queryParams['name'] <- name

      queryParams['md5'] <- md5

      queryParams['after'] <- after

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      urlPath <- "/rest/Medias/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteMediaType = function(id, ...){
      apiResponse <- self$DeleteMediaTypeWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteMediaTypeWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/MediaType/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteMembership = function(id, ...){
      apiResponse <- self$DeleteMembershipWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteMembershipWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/Membership/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteProject = function(id, ...){
      apiResponse <- self$DeleteProjectWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteProjectWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/Project/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteState = function(id, ...){
      apiResponse <- self$DeleteStateWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteStateWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/State/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteStateList = function(project, media.query=NULL, media.id=NULL, type=NULL, version=NULL, modified=1, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      apiResponse <- self$DeleteStateListWithHttpInfo(project, media.query, media.id, type, version, modified, after, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteStateListWithHttpInfo = function(project, media.query=NULL, media.id=NULL, type=NULL, version=NULL, modified=1, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_query'] <- media.query

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      queryParams['version'] <- version

      queryParams['modified'] <- modified

      queryParams['after'] <- after

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      urlPath <- "/rest/States/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteStateType = function(id, ...){
      apiResponse <- self$DeleteStateTypeWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteStateTypeWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/StateType/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteTemporaryFile = function(id, ...){
      apiResponse <- self$DeleteTemporaryFileWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteTemporaryFileWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/TemporaryFile/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteTemporaryFileList = function(project, expired=0, ...){
      apiResponse <- self$DeleteTemporaryFileListWithHttpInfo(project, expired, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteTemporaryFileListWithHttpInfo = function(project, expired=0, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['expired'] <- expired

      urlPath <- "/rest/TemporaryFiles/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteVersion = function(id, ...){
      apiResponse <- self$DeleteVersionWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteVersionWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/Version/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetAlgorithmList = function(project, ...){
      apiResponse <- self$GetAlgorithmListWithHttpInfo(project, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetAlgorithmListWithHttpInfo = function(project, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      urlPath <- "/rest/Algorithms/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[Algorithm]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetAnalysisList = function(project, ...){
      apiResponse <- self$GetAnalysisListWithHttpInfo(project, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetAnalysisListWithHttpInfo = function(project, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      urlPath <- "/rest/Analyses/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[Analysis]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetClip = function(id, frame.ranges, quality=NULL, ...){
      apiResponse <- self$GetClipWithHttpInfo(id, frame.ranges, quality, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetClipWithHttpInfo = function(id, frame.ranges, quality=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (missing(`frame.ranges`)) {
        stop("Missing required parameter `frame.ranges`.")
      }

      queryParams['frameRanges'] <- frame.ranges

      queryParams['quality'] <- quality

      urlPath <- "/rest/GetClip/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "TemporaryFile", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetFrame = function(id, frames=c(0), tile=NULL, roi=NULL, animate=NULL, quality=NULL, ...){
      apiResponse <- self$GetFrameWithHttpInfo(id, frames, tile, roi, animate, quality, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetFrameWithHttpInfo = function(id, frames=c(0), tile=NULL, roi=NULL, animate=NULL, quality=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      queryParams['frames'] <- frames

      queryParams['tile'] <- tile

      queryParams['roi'] <- roi

      queryParams['animate'] <- animate

      queryParams['quality'] <- quality

      urlPath <- "/rest/GetFrame/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetLeaf = function(id, ...){
      apiResponse <- self$GetLeafWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetLeafWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/Leaf/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Leaf", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetLeafList = function(project, ancestor=NULL, type=NULL, name=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      apiResponse <- self$GetLeafListWithHttpInfo(project, ancestor, type, name, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetLeafListWithHttpInfo = function(project, ancestor=NULL, type=NULL, name=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['ancestor'] <- ancestor

      queryParams['type'] <- type

      queryParams['name'] <- name

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      urlPath <- "/rest/Leaves/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[Leaf]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetLeafType = function(id, ...){
      apiResponse <- self$GetLeafTypeWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetLeafTypeWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/LeafType/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "LeafType", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetLeafTypeList = function(project, ...){
      apiResponse <- self$GetLeafTypeListWithHttpInfo(project, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetLeafTypeListWithHttpInfo = function(project, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      urlPath <- "/rest/LeafTypes/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[LeafType]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetLocalization = function(id, ...){
      apiResponse <- self$GetLocalizationWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetLocalizationWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/Localization/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Localization", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetLocalizationList = function(project, media.query=NULL, media.id=NULL, type=NULL, version=NULL, modified=1, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, exclude.parents=0, frame=NULL, ...){
      apiResponse <- self$GetLocalizationListWithHttpInfo(project, media.query, media.id, type, version, modified, after, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, exclude.parents, frame, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetLocalizationListWithHttpInfo = function(project, media.query=NULL, media.id=NULL, type=NULL, version=NULL, modified=1, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, exclude.parents=0, frame=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_query'] <- media.query

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      queryParams['version'] <- version

      queryParams['modified'] <- modified

      queryParams['after'] <- after

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      queryParams['excludeParents'] <- exclude.parents

      queryParams['frame'] <- frame

      urlPath <- "/rest/Localizations/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[Localization]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetLocalizationType = function(id, ...){
      apiResponse <- self$GetLocalizationTypeWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetLocalizationTypeWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/LocalizationType/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "LocalizationType", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetLocalizationTypeList = function(project, media.id=NULL, type=NULL, ...){
      apiResponse <- self$GetLocalizationTypeListWithHttpInfo(project, media.id, type, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetLocalizationTypeListWithHttpInfo = function(project, media.id=NULL, type=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      urlPath <- "/rest/LocalizationTypes/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[LocalizationType]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetMedia = function(id, ...){
      apiResponse <- self$GetMediaWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetMediaWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/Media/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Media", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetMediaList = function(project, media.id=NULL, type=NULL, name=NULL, md5=NULL, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      apiResponse <- self$GetMediaListWithHttpInfo(project, media.id, type, name, md5, after, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetMediaListWithHttpInfo = function(project, media.id=NULL, type=NULL, name=NULL, md5=NULL, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      queryParams['name'] <- name

      queryParams['md5'] <- md5

      queryParams['after'] <- after

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      urlPath <- "/rest/Medias/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[Media]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetMediaNext = function(id, media.id=NULL, type=NULL, name=NULL, md5=NULL, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      apiResponse <- self$GetMediaNextWithHttpInfo(id, media.id, type, name, md5, after, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetMediaNextWithHttpInfo = function(id, media.id=NULL, type=NULL, name=NULL, md5=NULL, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      queryParams['name'] <- name

      queryParams['md5'] <- md5

      queryParams['after'] <- after

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      urlPath <- "/rest/MediaNext/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MediaNext", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetMediaPrev = function(id, media.id=NULL, type=NULL, name=NULL, md5=NULL, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      apiResponse <- self$GetMediaPrevWithHttpInfo(id, media.id, type, name, md5, after, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetMediaPrevWithHttpInfo = function(id, media.id=NULL, type=NULL, name=NULL, md5=NULL, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      queryParams['name'] <- name

      queryParams['md5'] <- md5

      queryParams['after'] <- after

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      urlPath <- "/rest/MediaPrev/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MediaPrev", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetMediaSections = function(project, media.id=NULL, type=NULL, name=NULL, md5=NULL, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      apiResponse <- self$GetMediaSectionsWithHttpInfo(project, media.id, type, name, md5, after, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetMediaSectionsWithHttpInfo = function(project, media.id=NULL, type=NULL, name=NULL, md5=NULL, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      queryParams['name'] <- name

      queryParams['md5'] <- md5

      queryParams['after'] <- after

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      urlPath <- "/rest/MediaSections/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "map(object)", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetMediaType = function(id, ...){
      apiResponse <- self$GetMediaTypeWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetMediaTypeWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/MediaType/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MediaType", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetMediaTypeList = function(project, ...){
      apiResponse <- self$GetMediaTypeListWithHttpInfo(project, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetMediaTypeListWithHttpInfo = function(project, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      urlPath <- "/rest/MediaTypes/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[MediaType]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetMembership = function(id, ...){
      apiResponse <- self$GetMembershipWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetMembershipWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/Membership/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Membership", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetMembershipList = function(project, ...){
      apiResponse <- self$GetMembershipListWithHttpInfo(project, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetMembershipListWithHttpInfo = function(project, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      urlPath <- "/rest/Memberships/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[Membership]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetProject = function(id, ...){
      apiResponse <- self$GetProjectWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetProjectWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/Project/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Project", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetProjectList = function(...){
      apiResponse <- self$GetProjectListWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetProjectListWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      urlPath <- "/rest/Projects"
      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[Project]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetSectionAnalysis = function(project, media.id=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      apiResponse <- self$GetSectionAnalysisWithHttpInfo(project, media.id, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetSectionAnalysisWithHttpInfo = function(project, media.id=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_id'] <- media.id

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      urlPath <- "/rest/SectionAnalysis/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "map(AnyType)", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetState = function(id, ...){
      apiResponse <- self$GetStateWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetStateWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/State/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "State", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetStateGraphic = function(id, mode='animate', fps=2, force.scale=NULL, ...){
      apiResponse <- self$GetStateGraphicWithHttpInfo(id, mode, fps, force.scale, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetStateGraphicWithHttpInfo = function(id, mode='animate', fps=2, force.scale=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      queryParams['mode'] <- mode

      queryParams['fps'] <- fps

      queryParams['forceScale'] <- force.scale

      urlPath <- "/rest/StateGraphic/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetStateList = function(project, media.query=NULL, media.id=NULL, type=NULL, version=NULL, modified=1, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      apiResponse <- self$GetStateListWithHttpInfo(project, media.query, media.id, type, version, modified, after, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetStateListWithHttpInfo = function(project, media.query=NULL, media.id=NULL, type=NULL, version=NULL, modified=1, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_query'] <- media.query

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      queryParams['version'] <- version

      queryParams['modified'] <- modified

      queryParams['after'] <- after

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      urlPath <- "/rest/States/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[State]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetStateType = function(id, ...){
      apiResponse <- self$GetStateTypeWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetStateTypeWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/StateType/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "StateType", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetStateTypeList = function(project, media.id=NULL, type=NULL, ...){
      apiResponse <- self$GetStateTypeListWithHttpInfo(project, media.id, type, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetStateTypeListWithHttpInfo = function(project, media.id=NULL, type=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      urlPath <- "/rest/StateTypes/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[StateType]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetTemporaryFile = function(id, ...){
      apiResponse <- self$GetTemporaryFileWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetTemporaryFileWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/TemporaryFile/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "TemporaryFile", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetTemporaryFileList = function(project, expired=0, ...){
      apiResponse <- self$GetTemporaryFileListWithHttpInfo(project, expired, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetTemporaryFileListWithHttpInfo = function(project, expired=0, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['expired'] <- expired

      urlPath <- "/rest/TemporaryFiles/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[TemporaryFile]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetUser = function(id, ...){
      apiResponse <- self$GetUserWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetUserWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/User/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "User", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetVersion = function(id, ...){
      apiResponse <- self$GetVersionWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetVersionWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      urlPath <- "/rest/Version/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Version", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetVersionList = function(project, media.id=NULL, ...){
      apiResponse <- self$GetVersionListWithHttpInfo(project, media.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetVersionListWithHttpInfo = function(project, media.id=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_id'] <- media.id

      urlPath <- "/rest/Versions/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[Version]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    LeafSuggestion = function(project, ancestor, query, min.level=NULL, ...){
      apiResponse <- self$LeafSuggestionWithHttpInfo(project, ancestor, query, min.level, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    LeafSuggestionWithHttpInfo = function(project, ancestor, query, min.level=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (missing(`ancestor`)) {
        stop("Missing required parameter `ancestor`.")
      }

      if (missing(`query`)) {
        stop("Missing required parameter `query`.")
      }

      queryParams['minLevel'] <- min.level

      queryParams['query'] <- query

      urlPath <- "/rest/Leaves/Suggestion/{ancestor}/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      if (!missing(`ancestor`)) {
        urlPath <- gsub(paste0("\\{", "ancestor", "\\}"), URLencode(as.character(`ancestor`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[LeafSuggestion]", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    Notify = function(notify.spec=NULL, ...){
      apiResponse <- self$NotifyWithHttpInfo(notify.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    NotifyWithHttpInfo = function(notify.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`notify.spec`)) {
        body <- `notify.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Notify"
      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    Progress = function(project, progress.spec=NULL, ...){
      apiResponse <- self$ProgressWithHttpInfo(project, progress.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ProgressWithHttpInfo = function(project, progress.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`progress.spec`)) {
        body.items = paste(unlist(lapply(progress.spec, function(param){param$toJSONString()})), collapse = ",")
        body <- paste0('[', body.items, ']')
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Progress/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    SaveImage = function(project, image.spec=NULL, ...){
      apiResponse <- self$SaveImageWithHttpInfo(project, image.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SaveImageWithHttpInfo = function(project, image.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`image.spec`)) {
        body <- `image.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/SaveImage/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    SaveVideo = function(project, video.spec=NULL, ...){
      apiResponse <- self$SaveVideoWithHttpInfo(project, video.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SaveVideoWithHttpInfo = function(project, video.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`video.spec`)) {
        body <- `video.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/SaveVideo/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CreateResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    Transcode = function(project, transcode.spec=NULL, ...){
      apiResponse <- self$TranscodeWithHttpInfo(project, transcode.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    TranscodeWithHttpInfo = function(project, transcode.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`transcode.spec`)) {
        body <- `transcode.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Transcode/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "Transcode", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateLeaf = function(id, leaf.update=NULL, ...){
      apiResponse <- self$UpdateLeafWithHttpInfo(id, leaf.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateLeafWithHttpInfo = function(id, leaf.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`leaf.update`)) {
        body <- `leaf.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Leaf/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateLeafList = function(project, ancestor=NULL, type=NULL, name=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, attribute.bulk.update=NULL, ...){
      apiResponse <- self$UpdateLeafListWithHttpInfo(project, ancestor, type, name, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, attribute.bulk.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateLeafListWithHttpInfo = function(project, ancestor=NULL, type=NULL, name=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, attribute.bulk.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['ancestor'] <- ancestor

      queryParams['type'] <- type

      queryParams['name'] <- name

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      if (!missing(`attribute.bulk.update`)) {
        body <- `attribute.bulk.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Leaves/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateLeafType = function(id, leaf.type.update=NULL, ...){
      apiResponse <- self$UpdateLeafTypeWithHttpInfo(id, leaf.type.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateLeafTypeWithHttpInfo = function(id, leaf.type.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`leaf.type.update`)) {
        body <- `leaf.type.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/LeafType/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateLocalization = function(id, localization.update=NULL, ...){
      apiResponse <- self$UpdateLocalizationWithHttpInfo(id, localization.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateLocalizationWithHttpInfo = function(id, localization.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`localization.update`)) {
        body <- `localization.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Localization/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateLocalizationList = function(project, media.query=NULL, media.id=NULL, type=NULL, version=NULL, modified=1, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, exclude.parents=0, frame=NULL, attribute.bulk.update=NULL, ...){
      apiResponse <- self$UpdateLocalizationListWithHttpInfo(project, media.query, media.id, type, version, modified, after, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, exclude.parents, frame, attribute.bulk.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateLocalizationListWithHttpInfo = function(project, media.query=NULL, media.id=NULL, type=NULL, version=NULL, modified=1, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, exclude.parents=0, frame=NULL, attribute.bulk.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_query'] <- media.query

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      queryParams['version'] <- version

      queryParams['modified'] <- modified

      queryParams['after'] <- after

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      queryParams['excludeParents'] <- exclude.parents

      queryParams['frame'] <- frame

      if (!missing(`attribute.bulk.update`)) {
        body <- `attribute.bulk.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Localizations/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateLocalizationType = function(id, localization.type.update=NULL, ...){
      apiResponse <- self$UpdateLocalizationTypeWithHttpInfo(id, localization.type.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateLocalizationTypeWithHttpInfo = function(id, localization.type.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`localization.type.update`)) {
        body <- `localization.type.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/LocalizationType/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateMedia = function(id, media.update=NULL, ...){
      apiResponse <- self$UpdateMediaWithHttpInfo(id, media.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateMediaWithHttpInfo = function(id, media.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`media.update`)) {
        body <- `media.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Media/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateMediaList = function(project, media.id=NULL, type=NULL, name=NULL, md5=NULL, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, attribute.bulk.update=NULL, ...){
      apiResponse <- self$UpdateMediaListWithHttpInfo(project, media.id, type, name, md5, after, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, attribute.bulk.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateMediaListWithHttpInfo = function(project, media.id=NULL, type=NULL, name=NULL, md5=NULL, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, attribute.bulk.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      queryParams['name'] <- name

      queryParams['md5'] <- md5

      queryParams['after'] <- after

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      if (!missing(`attribute.bulk.update`)) {
        body <- `attribute.bulk.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Medias/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateMediaType = function(id, media.type.update=NULL, ...){
      apiResponse <- self$UpdateMediaTypeWithHttpInfo(id, media.type.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateMediaTypeWithHttpInfo = function(id, media.type.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`media.type.update`)) {
        body <- `media.type.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/MediaType/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateMembership = function(id, membership.update=NULL, ...){
      apiResponse <- self$UpdateMembershipWithHttpInfo(id, membership.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateMembershipWithHttpInfo = function(id, membership.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`membership.update`)) {
        body <- `membership.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Membership/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateProject = function(id, project.spec=NULL, ...){
      apiResponse <- self$UpdateProjectWithHttpInfo(id, project.spec, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateProjectWithHttpInfo = function(id, project.spec=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`project.spec`)) {
        body <- `project.spec`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Project/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateState = function(id, state.update=NULL, ...){
      apiResponse <- self$UpdateStateWithHttpInfo(id, state.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateStateWithHttpInfo = function(id, state.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`state.update`)) {
        body <- `state.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/State/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateStateList = function(project, media.query=NULL, media.id=NULL, type=NULL, version=NULL, modified=1, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, attribute.bulk.update=NULL, ...){
      apiResponse <- self$UpdateStateListWithHttpInfo(project, media.query, media.id, type, version, modified, after, search, attribute, attribute.lt, attribute.lte, attribute.gt, attribute.gte, attribute.contains, attribute.distance, attribute.null, operation, start, stop, attribute.bulk.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateStateListWithHttpInfo = function(project, media.query=NULL, media.id=NULL, type=NULL, version=NULL, modified=1, after=NULL, search=NULL, attribute=NULL, attribute.lt=NULL, attribute.lte=NULL, attribute.gt=NULL, attribute.gte=NULL, attribute.contains=NULL, attribute.distance=NULL, attribute.null=NULL, operation=NULL, start=NULL, stop=NULL, attribute.bulk.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      queryParams['media_query'] <- media.query

      queryParams['media_id'] <- media.id

      queryParams['type'] <- type

      queryParams['version'] <- version

      queryParams['modified'] <- modified

      queryParams['after'] <- after

      queryParams['search'] <- search

      queryParams['attribute'] <- attribute

      queryParams['attribute_lt'] <- attribute.lt

      queryParams['attribute_lte'] <- attribute.lte

      queryParams['attribute_gt'] <- attribute.gt

      queryParams['attribute_gte'] <- attribute.gte

      queryParams['attribute_contains'] <- attribute.contains

      queryParams['attribute_distance'] <- attribute.distance

      queryParams['attribute_null'] <- attribute.null

      queryParams['operation'] <- operation

      queryParams['start'] <- start

      queryParams['stop'] <- stop

      if (!missing(`attribute.bulk.update`)) {
        body <- `attribute.bulk.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/States/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateStateType = function(id, state.type.update=NULL, ...){
      apiResponse <- self$UpdateStateTypeWithHttpInfo(id, state.type.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateStateTypeWithHttpInfo = function(id, state.type.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`state.type.update`)) {
        body <- `state.type.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/StateType/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateUser = function(id, user.update=NULL, ...){
      apiResponse <- self$UpdateUserWithHttpInfo(id, user.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateUserWithHttpInfo = function(id, user.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`user.update`)) {
        body <- `user.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/User/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateVersion = function(id, version.update=NULL, ...){
      apiResponse <- self$UpdateVersionWithHttpInfo(id, version.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateVersionWithHttpInfo = function(id, version.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      if (!missing(`version.update`)) {
        body <- `version.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/Version/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MessageResponse", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateVideo = function(project, video.update=NULL, ...){
      apiResponse <- self$UpdateVideoWithHttpInfo(project, video.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateVideoWithHttpInfo = function(project, video.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`project`)) {
        stop("Missing required parameter `project`.")
      }

      if (!missing(`video.update`)) {
        body <- `video.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/rest/SaveVideo/{project}"
      if (!missing(`project`)) {
        urlPath <- gsub(paste0("\\{", "project", "\\}"), URLencode(as.character(`project`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    Whoami = function(...){
      apiResponse <- self$WhoamiWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    WhoamiWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      urlPath <- "/rest/User/GetCurrent"
      # API key authentication
      if ("Authorization" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["Authorization"]) > 0) {
        headerParams['Authorization'] <- paste(unlist(self$apiClient$apiKeys["Authorization"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "User", loadNamespace("tator")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
